       to the current working directory.
             <code>
             using (ZipFile zip1 = ZipFile.Read(ZipFileName))
             {
                 var PhotoShopFiles = zip1.SelectEntries("*.psd");
                 foreach (ZipEntry psd in PhotoShopFiles)
                 {
                     psd.Extract();
                 }
             }
             </code>
             <code lang="VB">
             Using zip1 As ZipFile = ZipFile.Read(ZipFileName)
                 Dim PhotoShopFiles as ICollection(Of ZipEntry)
                 PhotoShopFiles = zip1.SelectEntries("*.psd")
                 Dim psd As ZipEntry
                 For Each psd In PhotoShopFiles
                     psd.Extract
                 Next
             End Using
             </code>
             </example>
             <param name="selectionCriteria">the string that specifies which entries to select</param>
             <returns>a collection of ZipEntry objects that conform to the inclusion spec</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.SelectEntries(System.String,System.String)">
             <summary>
             Retrieve entries from the zipfile by specified criteria.
             </summary>
            
             <remarks>
             <para>
             This method allows callers to retrieve the collection of entries from the zipfile
             that fit the specified criteria.  The criteria are described in a string format, and
             can include patterns for the filename; constraints on the size of the entry;
             constraints on the last modified, created, or last accessed time for the file
             described by the entry; or the attributes of the entry.
             </para>
            
             <para>
             For details on the syntax for the selectionCriteria parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)"/>.
             </para>
            
             <para>
             This method is intended for use with a ZipFile that has been read from storage.
             When creating a new ZipFile, this method will work only after the ZipArchive has
             been Saved to the disk (the ZipFile class subsequently and implicitly reads the Zip
             archive from storage.)  Calling SelectEntries on a ZipFile that has not yet been
             saved will deliver undefined results.
             </para>
             </remarks>
            
             <exception cref="T:System.Exception">
             Thrown if selectionCriteria has an invalid syntax.
             </exception>
            
             <example>
             <code>
             using (ZipFile zip1 = ZipFile.Read(ZipFileName))
             {
                 var UpdatedPhotoShopFiles = zip1.SelectEntries("*.psd", "UpdatedFiles");
                 foreach (ZipEntry e in UpdatedPhotoShopFiles)
                 {
                     // prompt for extract here
                     if (WantExtract(e.FileName))
                         e.Extract();
                 }
             }
             </code>
             <code lang="VB">
             Using zip1 As ZipFile = ZipFile.Read(ZipFileName)
                 Dim UpdatedPhotoShopFiles As ICollection(Of ZipEntry) = zip1.SelectEntries("*.psd", "UpdatedFiles")
                 Dim e As ZipEntry
                 For Each e In UpdatedPhotoShopFiles
                     ' prompt for extract here
                     If Me.WantExtract(e.FileName) Then
                         e.Extract
                     End If
                 Next
             End Using
             </code>
             </example>
             <param name="selectionCriteria">the string that specifies which entries to select</param>
            
             <param name="directoryPathInArchive">
             the directory in the archive from which to select entries. If null, then
             all directories in the archive are used.
             </param>
            
             <returns>a collection of ZipEntry objects that conform to the inclusion spec</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.RemoveSelectedEntries(System.String)">
             <summary>
             Remove entries from the zipfile by specified criteria.
             </summary>
            
             <remarks>
             <para>
             This method allows callers to remove the collection of entries from the zipfile
             that fit the specified criteria.  The criteria are described in a string format, and
             can include patterns for the filename; constraints on the size of the entry;
             constraints on the last modified, created, or last accessed time for the file
             described by the entry; or the attributes of the entry.
             </para>
            
             <para>
             For details on the syntax for the selectionCriteria parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)"/>.
             </para>
            
             <para>
             This method is intended for use with a ZipFile that has been read from storage.
             When creating a new ZipFile, this method will work only after the ZipArchive has
             been Saved to the disk (the ZipFile class subsequently and implicitly reads the Zip
             archive from storage.)  Calling SelectEntries on a ZipFile that has not yet been
             saved will deliver undefined results.
             </para>
             </remarks>
            
             <exception cref="T:System.Exception">
             Thrown if selectionCriteria has an invalid syntax.
             </exception>
            
             <example>
             This example removes all entries in a zip file that were modified prior to January 1st, 2008.
             <code>
             using (ZipFile zip1 = ZipFile.Read(ZipFileName))
             {
                 // remove all entries from prior to Jan 1, 2008
                 zip1.RemoveEntries("mtime &lt; 2008-01-01");
                 // don't forget to save the archive!
                 zip1.Save();
             }
             </code>
             <code lang="VB">
             Using zip As ZipFile = ZipFile.Read(ZipFileName)
                 ' remove all entries from prior to Jan 1, 2008
                 zip1.RemoveEntries("mtime &lt; 2008-01-01")
                 ' do not forget to save the archive!
                 zip1.Save
             End Using
             </code>
             </example>
             <param name="selectionCriteria">the string that specifies which entries to select</param>
             <returns>the number of entries removed</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.RemoveSelectedEntries(System.String,System.String)">
             <summary>
             Remove entries from the zipfile by specified criteria, and within the specified
             path in the archive.
             </summary>
            
             <remarks>
             <para>
             This method allows callers to remove the collection of entries from the zipfile
             that fit the specified criteria.  The criteria are described in a string format, and
             can include patterns for the filename; constraints on the size of the entry;
             constraints on the last modified, created, or last accessed time for the file
             described by the entry; or the attributes of the entry.
             </para>
            
             <para>
             For details on the syntax for the selectionCriteria parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)"/>.
             </para>
            
             <para>
             This method is intended for use with a ZipFile that has been read from storage.
             When creating a new ZipFile, this method will work only after the ZipArchive has
             been Saved to the disk (the ZipFile class subsequently and implicitly reads the Zip
             archive from storage.)  Calling SelectEntries on a ZipFile that has not yet been
             saved will deliver undefined results.
             </para>
             </remarks>
            
             <exception cref="T:System.Exception">
             Thrown if selectionCriteria has an invalid syntax.
             </exception>
            
             <example>
             <code>
             using (ZipFile zip1 = ZipFile.Read(ZipFileName))
             {
                 // remove all entries from prior to Jan 1, 2008
                 zip1.RemoveEntries("mtime &lt; 2008-01-01", "documents");
                 // a call to ZipFile.Save will make the modifications permanent
                 zip1.Save();
             }
             </code>
             <code lang="VB">
             Using zip As ZipFile = ZipFile.Read(ZipFileName)
                 ' remove all entries from prior to Jan 1, 2008
                 zip1.RemoveEntries("mtime &lt; 2008-01-01", "documents")
                 ' a call to ZipFile.Save will make the modifications permanent
                 zip1.Save
             End Using
             </code>
             </example>
            
             <param name="selectionCriteria">the string that specifies which entries to select</param>
             <param name="directoryPathInArchive">
             the directory in the archive from which to select entries. If null, then
             all directories in the archive are used.
             </param>
             <returns>the number of entries removed</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String)">
             <summary>
             Selects and Extracts a set of Entries from the ZipFile.
             </summary>
            
             <remarks>
             <para>
             The entries are extracted into the current working directory.
             </para>
            
             <para>
             If any of the files to be extracted already exist, then the action taken is as
             specified in the <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile"/> property on the
             corresponding ZipEntry instance.  By default, the action taken in this case is to
             throw an exception.
             </para>
            
             <para>
             For information on the syntax of the selectionCriteria string,
             see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)"/>.
             </para>
             </remarks>
            
             <example>
             This example shows how extract all XML files modified after 15 January 2009.
             <code>
             using (ZipFile zip = ZipFile.Read(zipArchiveName))
             {
               zip.ExtractSelectedEntries("name = *.xml  and  mtime &gt; 2009-01-15");
             }
             </code>
             </example>
             <param name="selectionCriteria">the selection criteria for entries to extract.</param>
            
             <seealso cref="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String,Ionic.Zip.ExtractExistingFileAction)"/>
        </member>
        <member name="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String,Ionic.Zip.ExtractExistingFileAction)">
             <summary>
             Selects and Extracts a set of Entries from the ZipFile.
             </summary>
            
             <remarks>
             <para>
             The entries are extracted into the current working directory. When extraction would would
             overwrite an existing filesystem file, the action taken is as specified in the
             <paramref name="extractExistingFile"/> parameter.
             </para>
            
             <para>
             For information on the syntax of the string describing the entry selection criteria,
             see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)"/>.
             </para>
             </remarks>
            
             <example>
             This example shows how extract all XML files modified after 15 January 2009,
             overwriting any existing files.
             <code>
             using (ZipFile zip = ZipFile.Read(zipArchiveName))
             {
               zip.ExtractSelectedEntries("name = *.xml  and  mtime &gt; 2009-01-15",
                                          ExtractExistingFileAction.OverwriteSilently);
             }
             </code>
             </example>
            
             <param name="selectionCriteria">the selection criteria for entries to extract.</param>
            
             <param name="extractExistingFile">
             The action to take if extraction would overwrite an existing file.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String,System.String)">
             <summary>
             Selects and Extracts a set of Entries from the ZipFile.
             </summary>
            
             <remarks>
             <para>
             The entries are selected from the specified directory within the archive, and then
             extracted into the current working directory.
             </para>
            
             <para>
             If any of the files to be extracted already exist, then the action taken is as
             specified in the <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile"/> property on the
             corresponding ZipEntry instance.  By default, the action taken in this case is to
             throw an exception.
             </para>
            
             <para>
             For information on the syntax of the string describing the entry selection criteria,
             see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)"/>.
             </para>
             </remarks>
            
             <example>
             This example shows how extract all XML files modified after 15 January 2009,
             and writes them to the "unpack" directory.
             <code>
             using (ZipFile zip = ZipFile.Read(zipArchiveName))
             {
               zip.ExtractSelectedEntries("name = *.xml  and  mtime &gt; 2009-01-15","unpack");
             }
             </code>
             </example>
            
             <param name="selectionCriteria">the selection criteria for entries to extract.</param>
            
             <param name="directoryPathInArchive">
             the directory in the archive from which to select entries. If null, then
             all directories in the archive are used.
             </param>
            
             <seealso cref="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String,System.String,System.String,Ionic.Zip.ExtractExistingFileAction)"/>
        </member>
        <member name="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String,System.String,System.String)">
             <summary>
             Selects and Extracts a set of Entries from the ZipFile.
             </summary>
            
             <remarks>
             <para>
             The entries are extracted into the specified directory. If any of the files to be
             extracted already exist, an exception will be thrown.
             </para>
             <para>
             For information on the syntax of the string describing the entry selection criteria,
             see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)"/>.
             </para>
             </remarks>
            
             <param name="selectionCriteria">the selection criteria for entries to extract.</param>
            
             <param name="directoryInArchive">
             the directory in the archive from which to select entries. If null, then
             all directories in the archive are used.
             </param>
            
             <param name="extractDirectory">
             the directory on the disk into which to extract. It will be created
             if it does not exist.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String,System.String,System.String,Ionic.Zip.ExtractExistingFileAction)">
             <summary>
             Selects and Extracts a set of Entries from the ZipFile.
             </summary>
            
             <remarks>
             <para>
             The entries are extracted into the specified directory. When extraction would would
             overwrite an existing filesystem file, the action taken is as specified in the
             <paramref name="extractExistingFile"/> parameter.
             </para>
            
             <para>
             For information on the syntax of the string describing the entry selection criteria,
             see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)"/>.
             </para>
             </remarks>
            
             <example>
             This example shows how extract all files  with an XML extension or with  a size larger than 100,000 bytes,
             and puts them in the unpack directory.  For any files that already exist in
             that destination directory, they will not be overwritten.
             <code>
             using (ZipFile zip = ZipFile.Read(zipArchiveName))
             {
               zip.ExtractSelectedEntries("name = *.xml  or  size &gt; 100000",
                                          null,
                                          "unpack",
                                          ExtractExistingFileAction.DontOverwrite);
             }
             </code>
             </example>
            
             <param name="selectionCriteria">the selection criteria for entries to extract.</param>
            
             <param name="extractDirectory">
             The directory on the disk into which to extract. It will be created if it does not exist.
             </param>
            
             <param name="directoryPathInArchive">
             The directory in the archive from which to select entries. If null, then
             all directories in the archive are used.
             </param>
            
             <param name="extractExistingFile">
             The action to take if extraction would overwrite an existing file.
             </param>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.SaveSelfExtractor(System.String,Ionic.Zip.SelfExtractorFlavor)">
             <summary>
             Saves the ZipFile instance to a self-extracting zip archive.
             </summary>
            
             <remarks>
            
             <para>
             The generated exe image will execute on any machine that has the .NET
             Framework 2.0 installed on it.  The generated exe image is also a
             valid ZIP file, readable with DotNetZip or another Zip library or tool
             such as WinZip.
             </para>
            
             <para>
             There are two "flavors" of self-extracting archive.  The
             <c>WinFormsApplication</c> version will pop up a GUI and allow the
             user to select a target directory into which to extract. There's also
             a checkbox allowing the user to specify to overwrite existing files,
             and another checkbox to allow the user to request that Explorer be
             opened to see the extracted files after extraction.  The other flavor
             is <c>ConsoleApplication</c>.  A self-extractor generated with that
             flavor setting will run from the command line. It accepts command-line
             options to set the overwrite behavior, and to specify the target
             extraction directory.
             </para>
            
             <para>
             There are a few temporary files created during the saving to a
             self-extracting zip.  These files are created in the directory pointed
             to by <see cref="P:Ionic.Zip.ZipFile.TempFileFolder"/>, which defaults to <see cref="M:System.IO.Path.GetTempPath"/>.  These temporary files are
             removed upon successful completion of this method.
             </para>
            
             <para>
             When a user runs the WinForms SFX, the user's personal directory (<see cref="F:System.Environment.SpecialFolder.Personal">Environment.SpecialFolder.Personal</see>)
             will be used as the default extract location.  If you want to set the
             default extract location, you should use the other overload of
             <c>SaveSelfExtractor()</c>/ The user who runs the SFX will have the
             opportunity to change the extract directory before extracting. When
             the user runs the Command-Line SFX, the user must explicitly specify
             the directory to which to extract.  The .NET Framework 2.0 is required
             on the computer when the self-extracting archive is run.
             </para>
            
             <para>
             NB: This method is not available in the version of DotNetZip build for
             the .NET Compact Framework, nor in the "Reduced" DotNetZip library.
             </para>
            
             </remarks>
            
             <example>
             <code>
             string DirectoryPath = "c:\\Documents\\Project7";
             using (ZipFile zip = new ZipFile())
             {
                 zip.AddDirectory(DirectoryPath, System.IO.Path.GetFileName(DirectoryPath));
                 zip.Comment = "This will be embedded into a self-extracting console-based exe";
                 zip.SaveSelfExtractor("archive.exe", SelfExtractorFlavor.ConsoleApplication);
             }
             </code>
             <code lang="VB">
             Dim DirectoryPath As String = "c:\Documents\Project7"
             Using zip As New ZipFile()
                 zip.AddDirectory(DirectoryPath, System.IO.Path.GetFileName(DirectoryPath))
                 zip.Comment = "This will be embedded into a self-extracting console-based exe"
                 zip.SaveSelfExtractor("archive.exe", SelfExtractorFlavor.ConsoleApplication)
             End Using
             </code>
             </example>
            
             <param name="exeToGenerate">
               a pathname, possibly fully qualified, to be created. Typically it
               will end in an .exe extension.</param>
             <param name="flavor">
               Indicates whether a Winforms or Console self-extractor is
               desired. </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.SaveSelfExtractor(System.String,Ionic.Zip.SelfExtractorSaveOptions)">
             <summary>
               Saves the ZipFile instance to a self-extracting zip archive, using
               the specified save options.
             </summary>
            
             <remarks>
             <para>
               This method saves a self extracting archive, using the specified save
               options. These options include the flavor of the SFX, the default extract
               directory, the icon file, and so on.  See the documentation
               for <see cref="M:Ionic.Zip.ZipFile.SaveSelfExtractor(System.String,Ionic.Zip.SelfExtractorFlavor)"/> for more
               details.
             </para>
            
             <para>
               The user who runs the SFX will have the opportunity to change the extract
               directory before extracting. If at the time of extraction, the specified
               directory does not exist, the SFX will create the directory before
               extracting the files.
             </para>
            
             </remarks>
            
             <example>
               This example saves a WinForms-based self-extracting archive EXE that
               will use c:\ExtractHere as the default extract location. The C# code
               shows syntax for .NET 3.0, which uses an object initializer for
               the SelfExtractorOptions object.
             <code>
             string DirectoryPath = "c:\\Documents\\Project7";
             using (ZipFile zip = new ZipFile())
             {
                 zip.AddDirectory(DirectoryPath, System.IO.Path.GetFileName(DirectoryPath));
                 zip.Comment = "This will be embedded into a self-extracting WinForms-based exe";
                 var options = new SelfExtractorOptions
                 {
                   Flavor = SelfExtractorFlavor.WinFormsApplication,
                   DefaultExtractDirectory = "%USERPROFILE%\\ExtractHere",
                   PostExtractCommandLine = ExeToRunAfterExtract,
                   SfxExeWindowTitle = "My Custom Window Title",
                   RemoveUnpackedFilesAfterExecute = true
                 };
                 zip.SaveSelfExtractor("archive.exe", options);
             }
             </code>
             <code lang="VB">
             Dim DirectoryPath As String = "c:\Documents\Project7"
             Using zip As New ZipFile()
                 zip.AddDirectory(DirectoryPath, System.IO.Path.GetFileName(DirectoryPath))
                 zip.Comment = "This will be embedded into a self-extracting console-based exe"
                 Dim options As New SelfExtractorOptions()
                 options.Flavor = SelfExtractorFlavor.WinFormsApplication
                 options.DefaultExtractDirectory = "%USERPROFILE%\\ExtractHere"
                 options.PostExtractCommandLine = ExeToRunAfterExtract
                 options.SfxExeWindowTitle = "My Custom Window Title"
                 options.RemoveUnpackedFilesAfterExecute = True
                 zip.SaveSelfExtractor("archive.exe", options)
             End Using
             </code>
             </example>
            
             <param name="exeToGenerate">The name of the EXE to generate.</param>
             <param name="options">provides the options for creating the
             Self-extracting archive.</param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.GetEnumerator">
             <summary>
             Generic IEnumerator support, for use of a ZipFile in an enumeration.
             </summary>
            
             <remarks>
             You probably do not want to call <c>GetEnumerator</c> explicitly. Instead
             it is implicitly called when you use a <see langword="foreach"/> loop in C#, or a
             <c>For Each</c> loop in VB.NET.
             </remarks>
            
             <example>
             This example reads a zipfile of a given name, then enumerates the
             entries in that zip file, and displays the information about each
             entry on the Console.
             <code>
             using (ZipFile zip = ZipFile.Read(zipfile))
             {
               bool header = true;
               foreach (ZipEntry e in zip)
               {
                 if (header)
                 {
                    System.Console.WriteLine("Zipfile: {0}", zip.Name);
                    System.Console.WriteLine("Version Needed: 0x{0:X2}", e.VersionNeeded);
                    System.Console.WriteLine("BitField: 0x{0:X2}", e.BitField);
                    System.Console.WriteLine("Compression Method: 0x{0:X2}", e.CompressionMethod);
                    System.Console.WriteLine("\n{1,-22} {2,-6} {3,4}   {4,-8}  {0}",
                                 "Filename", "Modified", "Size", "Ratio", "Packed");
                    System.Console.WriteLine(new System.String('-', 72));
                    header = false;
                 }
            
                 System.Console.WriteLine("{1,-22} {2,-6} {3,4:F0}%   {4,-8}  {0}",
                             e.FileName,
                             e.LastModified.ToString("yyyy-MM-dd HH:mm:ss"),
                             e.UncompressedSize,
                             e.CompressionRatio,
                             e.CompressedSize);
            
                 e.Extract();
               }
             }
             </code>
            
             <code lang="VB">
               Dim ZipFileToExtract As String = "c:\foo.zip"
               Using zip As ZipFile = ZipFile.Read(ZipFileToExtract)
                   Dim header As Boolean = True
                   Dim e As ZipEntry
                   For Each e In zip
                       If header Then
                           Console.WriteLine("Zipfile: {0}", zip.Name)
                           Console.WriteLine("Version Needed: 0x{0:X2}", e.VersionNeeded)
                           Console.WriteLine("BitField: 0x{0:X2}", e.BitField)
                           Console.WriteLine("Compression Method: 0x{0:X2}", e.CompressionMethod)
                           Console.WriteLine(ChrW(10) &amp; "{1,-22} {2,-6} {3,4}   {4,-8}  {0}", _
                             "Filename", "Modified", "Size", "Ratio", "Packed" )
                           Console.WriteLine(New String("-"c, 72))
                           header = False
                       End If
                       Console.WriteLine("{1,-22} {2,-6} {3,4:F0}%   {4,-8}  {0}", _
                         e.FileName, _
                         e.LastModified.ToString("yyyy-MM-dd HH:mm:ss"), _
                         e.UncompressedSize, _
                         e.CompressionRatio, _
                         e.CompressedSize )
                       e.Extract
                   Next
               End Using
             </code>
             </example>
            
             <returns>A generic enumerator suitable for use  within a foreach loop.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.GetNewEnum">
             <summary>
             An IEnumerator, for use of a ZipFile in a foreach construct.
             </summary>
            
             <remarks>
             This method is included for COM support.  An application generally does not call
             this method directly.  It is called implicitly by COM clients when enumerating
             the entries in the ZipFile instance.  In VBScript, this is done with a <c>For Each</c>
             statement.  In Javascript, this is done with <c>new Enumerator(zipfile)</c>.
             </remarks>
            
             <returns>
             The IEnumerator over the entries in the ZipFile.
             </returns>
        </member>
        <member name="P:Ionic.Zip.ZipFile.Info">
             <summary>
               Provides a human-readable string with information about the ZipFile.
             </summary>
            
             <remarks>
               <para>
                 The information string contains 10 lines or so, about each ZipEntry,
                 describing whether encryption is in use, the compressed and uncompressed
                 length of the entry, the offset of the entry, and so on. As a result the
                 information string can be very long for zip files that contain many
                 entries.
               </para>
               <para>
                 This information is mostly useful for diagnostic purposes.
               </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.FullScan">
             <summary>
             Indicates whether to perform a full scan of the zip file when reading it.
             </summary>
            
             <remarks>
            
             <para>
               You almost never want to use this property.
             </para>
            
             <para>
               When reading a zip file, if this flag is <c>true</c> (<c>True</c> in
               VB), the entire zip archive will be scanned and searched for entries.
               For large archives, this can take a very, long time. The much more
               efficient default behavior is to read the zip directory, which is
               stored at the end of the zip file. But, in some cases the directory is
               corrupted and you need to perform a full scan of the zip file to
               determine the contents of the zip file. This property lets you do
               that, when necessary.
             </para>
            
             <para>
               This flag is effective only when calling <see cref="M:Ionic.Zip.ZipFile.Initialize(System.String)"/>. Normally you would read a ZipFile with the
               static <see cref="M:Ionic.Zip.ZipFile.Read(System.String)">ZipFile.Read</see>
               method. But you can't set the <c>FullScan</c> property on the
               <c>ZipFile</c> instance when you use a static factory method like
               <c>ZipFile.Read</c>.
             </para>
            
             </remarks>
            
             <example>
            
               This example shows how to read a zip file using the full scan approach,
               and then save it, thereby producing a corrected zip file.
            
             <code lang="C#">
             using (var zip = new ZipFile())
             {
                 zip.FullScan = true;
                 zip.Initialize(zipFileName);
                 zip.Save(newName);
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile
                 zip.FullScan = True
                 zip.Initialize(zipFileName)
                 zip.Save(newName)
             End Using
             </code>
             </example>
            
        </member>
        <member name="P:Ionic.Zip.ZipFile.SortEntriesBeforeSaving">
             <summary>
               Whether to sort the ZipEntries before saving the file.
             </summary>
            
             <remarks>
               The default is false.  If you have a large number of zip entries, the sort
               alone can consume significant time.
             </remarks>
            
             <example>
             <code lang="C#">
             using (var zip = new ZipFile())
             {
                 zip.AddFiles(filesToAdd);
                 zip.SortEntriesBeforeSaving = true;
                 zip.Save(name);
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile
                 zip.AddFiles(filesToAdd)
                 zip.SortEntriesBeforeSaving = True
                 zip.Save(name)
             End Using
             </code>
             </example>
            
        </member>
        <member name="P:Ionic.Zip.ZipFile.AddDirectoryWillTraverseReparsePoints">
             <summary>
               Indicates whether NTFS Reparse Points, like junctions, should be
               traversed during calls to <c>AddDirectory()</c>.
             </summary>
            
             <remarks>
               By default, calls to AddDirectory() will traverse NTFS reparse
               points, like mounted volumes, and directory junctions.  An example
               of a junction is the "My Music" directory in Windows Vista.  In some
               cases you may not want DotNetZip to traverse those directories.  In
               that case, set this property to false.
             </remarks>
            
             <example>
             <code lang="C#">
             using (var zip = new ZipFile())
             {
                 zip.AddDirectoryWillTraverseReparsePoints = false;
                 zip.AddDirectory(dirToZip,"fodder");
                 zip.Save(zipFileToCreate);
             }
             </code>
             </example>
        </member>
        <member name="P:Ionic.Zip.ZipFile.BufferSize">
             <summary>
               Size of the IO buffer used while saving.
             </summary>
            
             <remarks>
            
             <para>
               First, let me say that you really don't need to bother with this.  It is
               here to allow for optimizations that you probably won't make! It will work
               fine if you don't set or get this property at all. Ok?
             </para>
            
             <para>
               Now that we have <em>that</em> out of the way, the fine print: This
               property affects the size of the buffer that is used for I/O for each
               entry contained in the zip file. When a file is read in to be compressed,
               it uses a buffer given by the size here.  When you update a zip file, the
               data for unmodified entries is copied from the first zip file to the
               other, through a buffer given by the size here.
             </para>
            
             <para>
               Changing the buffer size affects a few things: first, for larger buffer
               sizes, the memory used by the <c>ZipFile</c>, obviously, will be larger
               during I/O operations.  This may make operations faster for very much
               larger files.  Last, for any given entry, when you use a larger buffer
               there will be fewer progress events during I/O operations, because there's
               one progress event generated for each time the buffer is filled and then
               emptied.
             </para>
            
             <para>
               The default buffer size is 8k.  Increasing the buffer size may speed
               things up as you compress larger files.  But there are no hard-and-fast
               rules here, eh?  You won't know til you test it.  And there will be a
               limit where ever larger buffers actually slow things down.  So as I said
               in the beginning, it's probably best if you don't set or get this property
               at all.
             </para>
            
             </remarks>
            
             <example>
             This example shows how you might set a large buffer size for efficiency when
             dealing with zip entries that are larger than 1gb.
             <code lang="C#">
             using (ZipFile zip = new ZipFile())
             {
                 zip.SaveProgress += this.zip1_SaveProgress;
                 zip.AddDirectory(directoryToZip, "");
                 zip.UseZip64WhenSaving = Zip64Option.Always;
                 zip.BufferSize = 65536*8; // 65536 * 8 = 512k
                 zip.Save(ZipFileToCreate);
             }
             </code>
             </example>
        </member>
        <member name="P:Ionic.Zip.ZipFile.CodecBufferSize">
             <summary>
               Size of the work buffer to use for the ZLIB codec during compression.
             </summary>
            
             <remarks>
               <para>
                 When doing ZLIB or Deflate compression, the library fills a buffer,
                 then passes it to the compressor for compression. Then the library
                 reads out the compressed bytes. This happens repeatedly until there
                 is no more uncompressed data to compress. This property sets the
                 size of the buffer that will be used for chunk-wise compression. In
                 order for the setting to take effect, your application needs to set
                 this property before calling one of the <c>ZipFile.Save()</c>
                 overloads.
               </para>
               <para>
                 Setting this affects the performance and memory efficiency of
                 compression and decompression. For larger files, setting this to a
                 larger size may improve compression performance, but the exact
                 numbers vary depending on available memory, the size of the streams
                 you are compressing, and a bunch of other variables. I don't have
                 good firm recommendations on how to set it.  You'll have to test it
                 yourself. Or just leave it alone and accept the default.
               </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.FlattenFoldersOnExtract">
             <summary>
               Indicates whether extracted files should keep their paths as
               stored in the zip archive.
             </summary>
            
             <remarks>
              <para>
                This property affects Extraction.  It is not used when creating zip
                archives.
              </para>
            
              <para>
                With this property set to <c>false</c>, the default, extracting entries
                from a zip file will create files in the filesystem that have the full
                path associated to the entry within the zip file.  With this property set
                to <c>true</c>, extracting entries from the zip file results in files
                with no path: the folders are "flattened."
              </para>
            
              <para>
                An example: suppose the zip file contains entries /directory1/file1.txt and
                /directory2/file2.txt.  With <c>FlattenFoldersOnExtract</c> set to false,
                the files created will be \directory1\file1.txt and \directory2\file2.txt.
                With the property set to true, the files created are file1.txt and file2.txt.
              </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.Strategy">
             <summary>
               The compression strategy to use for all entries.
             </summary>
            
             <remarks>
               Set the Strategy used by the ZLIB-compatible compressor, when
               compressing entries using the DEFLATE method. Different compression
               strategies work better on different sorts of data. The strategy
               parameter can affect the compression ratio and the speed of
               compression but not the correctness of the compresssion.  For more
               information see <see cref="T:Ionic.Zlib.CompressionStrategy">Ionic.Zlib.CompressionStrategy</see>.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.Name">
             <summary>
               The name of the <c>ZipFile</c>, on disk.
             </summary>
            
             <remarks>
            
             <para>
               When the <c>ZipFile</c> instance was created by reading an archive using
               one of the <c>ZipFile.Read</c> methods, this property represents the name
               of the zip file that was read.  When the <c>ZipFile</c> instance was
               created by using the no-argument constructor, this value is <c>null</c>
               (<c>Nothing</c> in VB).
             </para>
            
             <para>
               If you use the no-argument constructor, and you then explicitly set this
               property, when you call <see cref="M:Ionic.Zip.ZipFile.Save"/>, this name will
               specify the name of the zip file created.  Doing so is equivalent to
               calling <see cref="M:Ionic.Zip.ZipFile.Save(System.String)"/>.  When instantiating a
               <c>ZipFile</c> by reading from a stream or byte array, the <c>Name</c>
               property remains <c>null</c>.  When saving to a stream, the <c>Name</c>
               property is implicitly set to <c>null</c>.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.CompressionLevel">
             <summary>
               Sets the compression level to be used for entries subsequently added to
               the zip archive.
             </summary>
            
             <remarks>
              <para>
                Varying the compression level used on entries can affect the
                size-vs-speed tradeoff when compression and decompressing data streams
                or files.
              </para>
            
              <para>
                As with some other properties on the <c>ZipFile</c> class, like <see cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, and <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, setting this property on a <c>ZipFile</c>
                instance will cause the specified <c>CompressionLevel</c> to be used on all
                <see cref="T:Ionic.Zip.ZipEntry"/> items that are subsequently added to the
                <c>ZipFile</c> instance. If you set this property after you have added
                items to the <c>ZipFile</c>, but before you have called <c>Save()</c>,
                those items will not use the specified compression level.
              </para>
            
              <para>
                If you do not set this property, the default compression level is used,
                which normally gives a good balance of compression efficiency and
                compression speed.  In some tests, using <c>BestCompression</c> can
                double the time it takes to compress, while delivering just a small
                increase in compression efficiency.  This behavior will vary with the
                type of data you compress.  If you are in doubt, just leave this setting
                alone, and accept the default.
              </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.CompressionMethod">
            <summary>
              The compression method for the zipfile.
            </summary>
            <remarks>
              <para>
                By default, the compression method is <c>CompressionMethod.Deflate.</c>
              </para>
            </remarks>
            <seealso cref="T:Ionic.Zip.CompressionMethod"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.Comment">
             <summary>
               A comment attached to the zip archive.
             </summary>
            
             <remarks>
            
             <para>
               This property is read/write. It allows the application to specify a
               comment for the <c>ZipFile</c>, or read the comment for the
               <c>ZipFile</c>.  After setting this property, changes are only made
               permanent when you call a <c>Save()</c> method.
             </para>
            
             <para>
               According to <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
               zip specification</see>, the comment is not encrypted, even if there is a
               password set on the zip file.
             </para>
            
             <para>
               The specification does not describe how to indicate the encoding used
               on a comment string. Many "compliant" zip tools and libraries use
               IBM437 as the code page for comments; DotNetZip, too, follows that
               practice.  On the other hand, there are situations where you want a
               Comment to be encoded with something else, for example using code page
               950 "Big-5 Chinese". To fill that need, DotNetZip will encode the
               comment following the same procedure it follows for encoding
               filenames: (a) if <see cref="P:Ionic.Zip.ZipFile.AlternateEncodingUsage"/> is
               <c>Never</c>, it uses the default encoding (IBM437). (b) if <see cref="P:Ionic.Zip.ZipFile.AlternateEncodingUsage"/> is <c>Always</c>, it always uses the
               alternate encoding (<see cref="P:Ionic.Zip.ZipFile.AlternateEncoding"/>). (c) if <see cref="P:Ionic.Zip.ZipFile.AlternateEncodingUsage"/> is <c>AsNecessary</c>, it uses the
               alternate encoding only if the default encoding is not sufficient for
               encoding the comment - in other words if decoding the result does not
               produce the original string.  This decision is taken at the time of
               the call to <c>ZipFile.Save()</c>.
             </para>
            
             <para>
               When creating a zip archive using this library, it is possible to change
               the value of <see cref="P:Ionic.Zip.ZipFile.AlternateEncoding"/> between each
               entry you add, and between adding entries and the call to
               <c>Save()</c>. Don't do this.  It will likely result in a zip file that is
               not readable by any tool or application.  For best interoperability, leave
               <see cref="P:Ionic.Zip.ZipFile.AlternateEncoding"/> alone, or specify it only
               once, before adding any entries to the <c>ZipFile</c> instance.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.EmitTimesInWindowsFormatWhenSaving">
             <summary>
               Specifies whether the Creation, Access, and Modified times for entries
               added to the zip file will be emitted in Windows format
               when the zip archive is saved.
             </summary>
            
             <remarks>
             <para>
               An application creating a zip archive can use this flag to explicitly
               specify that the file times for the entries should or should not be stored
               in the zip archive in the format used by Windows. By default this flag is
               <c>true</c>, meaning the Windows-format times are stored in the zip
               archive.
             </para>
            
             <para>
               When adding an entry from a file or directory, the Creation (<see cref="P:Ionic.Zip.ZipEntry.CreationTime"/>), Access (<see cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>), and Modified (<see cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>) times for the given entry are
               automatically set from the filesystem values. When adding an entry from a
               stream or string, all three values are implicitly set to
               <c>DateTime.Now</c>.  Applications can also explicitly set those times by
               calling <see cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/>.
             </para>
            
             <para>
               <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
               zip specification</see> describes multiple ways to format these times in a
               zip file. One is the format Windows applications normally use: 100ns ticks
               since January 1, 1601 UTC.  The other is a format Unix applications typically
               use: seconds since January 1, 1970 UTC.  Each format can be stored in an
               "extra field" in the zip entry when saving the zip archive. The former
               uses an extra field with a Header Id of 0x000A, while the latter uses a
               header ID of 0x5455, although you probably don't need to know that.
             </para>
            
             <para>
               Not all tools and libraries can interpret these fields.  Windows
               compressed folders is one that can read the Windows Format timestamps,
               while I believe <see href="http://www.info-zip.org/">the Infozip
               tools</see> can read the Unix format timestamps. Some tools and libraries
               may be able to read only one or the other. DotNetZip can read or write
               times in either or both formats.
             </para>
            
             <para>
               The times stored are taken from <see cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>, <see cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>, and <see cref="P:Ionic.Zip.ZipEntry.CreationTime"/>.
             </para>
            
             <para>
               The value set here applies to all entries subsequently added to the
               <c>ZipFile</c>.
             </para>
            
             <para>
               This property is not mutually exclusive of the <see cref="P:Ionic.Zip.ZipFile.EmitTimesInUnixFormatWhenSaving"/> property. It is possible and
               legal and valid to produce a zip file that contains timestamps encoded in
               the Unix format as well as in the Windows format, in addition to the <see cref="P:Ionic.Zip.ZipEntry.LastModified">LastModified</see> time attached to each
               entry in the archive, a time that is always stored in "DOS format". And,
               notwithstanding the names PKWare uses for these time formats, any of them
               can be read and written by any computer, on any operating system.  But,
               there are no guarantees that a program running on Mac or Linux will
               gracefully handle a zip file with "Windows" formatted times, or that an
               application that does not use DotNetZip but runs on Windows will be able to
               handle file times in Unix format.
             </para>
            
             <para>
               When in doubt, test.  Sorry, I haven't got a complete list of tools and
               which sort of timestamps they can use and will tolerate.  If you get any
               good information and would like to pass it on, please do so and I will
               include that information in this documentation.
             </para>
             </remarks>
            
             <example>
               This example shows how to save a zip file that contains file timestamps
               in a format normally used by Unix.
             <code lang="C#">
             using (var zip = new ZipFile())
             {
                 // produce a zip file the Mac will like
                 zip.EmitTimesInWindowsFormatWhenSaving = false;
                 zip.EmitTimesInUnixFormatWhenSaving = true;
                 zip.AddDirectory(directoryToZip, "files");
                 zip.Save(outputFile);
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile
                 '' produce a zip file the Mac will like
                 zip.EmitTimesInWindowsFormatWhenSaving = False
                 zip.EmitTimesInUnixFormatWhenSaving = True
                 zip.AddDirectory(directoryToZip, "files")
                 zip.Save(outputFile)
             End Using
             </code>
             </example>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving"/>
             <seealso cref="P:Ionic.Zip.ZipFile.EmitTimesInUnixFormatWhenSaving"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.EmitTimesInUnixFormatWhenSaving">
             <summary>
             Specifies whether the Creation, Access, and Modified times
             for entries added to the zip file will be emitted in "Unix(tm)
             format" when the zip archive is saved.
             </summary>
            
             <remarks>
             <para>
               An application creating a zip archive can use this flag to explicitly
               specify that the file times for the entries should or should not be stored
               in the zip archive in the format used by Unix. By default this flag is
               <c>false</c>, meaning the Unix-format times are not stored in the zip
               archive.
             </para>
            
             <para>
               When adding an entry from a file or directory, the Creation (<see cref="P:Ionic.Zip.ZipEntry.CreationTime"/>), Access (<see cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>), and Modified (<see cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>) times for the given entry are
               automatically set from the filesystem values. When adding an entry from a
               stream or string, all three values are implicitly set to DateTime.Now.
               Applications can also explicitly set those times by calling <see cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/>.
             </para>
            
             <para>
               <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
               zip specification</see> describes multiple ways to format these times in a
               zip file. One is the format Windows applications normally use: 100ns ticks
               since January 1, 1601 UTC.  The other is a format Unix applications
               typically use: seconds since January 1, 1970 UTC.  Each format can be
               stored in an "extra field" in the zip entry when saving the zip
               archive. The former uses an extra field with a Header Id of 0x000A, while
               the latter uses a header ID of 0x5455, although you probably don't need to
               know that.
             </para>
            
             <para>
               Not all tools and libraries can interpret these fields.  Windows
               compressed folders is one that can read the Windows Format timestamps,
               while I believe the <see href="http://www.info-zip.org/">Infozip</see>
               tools can read the Unix format timestamps. Some tools and libraries may be
               able to read only one or the other.  DotNetZip can read or write times in
               either or both formats.
             </para>
            
             <para>
               The times stored are taken from <see cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>, <see cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>, and <see cref="P:Ionic.Zip.ZipEntry.CreationTime"/>.
             </para>
            
             <para>
               This property is not mutually exclusive of the <see cref="P:Ionic.Zip.ZipFile.EmitTimesInWindowsFormatWhenSaving"/> property. It is possible and
               legal and valid to produce a zip file that contains timestamps encoded in
               the Unix format as well as in the Windows format, in addition to the <see cref="P:Ionic.Zip.ZipEntry.LastModified">LastModified</see> time attached to each
               entry in the zip archive, a time that is always stored in "DOS
               format". And, notwithstanding the names PKWare uses for these time
               formats, any of them can be read and written by any computer, on any
               operating system.  But, there are no guarantees that a program running on
               Mac or Linux will gracefully handle a zip file with "Windows" formatted
               times, or that an application that does not use DotNetZip but runs on
               Windows will be able to handle file times in Unix format.
             </para>
            
             <para>
               When in doubt, test.  Sorry, I haven't got a complete list of tools and
               which sort of timestamps they can use and will tolerate.  If you get any
               good information and would like to pass it on, please do so and I will
               include that information in this documentation.
             </para>
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving"/>
             <seealso cref="P:Ionic.Zip.ZipFile.EmitTimesInWindowsFormatWhenSaving"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.Verbose">
             <summary>
               Indicates whether verbose output is sent to the <see cref="P:Ionic.Zip.ZipFile.StatusMessageTextWriter"/> during <c>AddXxx()</c> and
               <c>ReadXxx()</c> operations.
             </summary>
            
             <remarks>
               This is a <em>synthetic</em> property.  It returns true if the <see cref="P:Ionic.Zip.ZipFile.StatusMessageTextWriter"/> is non-null.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.CaseSensitiveRetrieval">
             <summary>
               Indicates whether to perform case-sensitive matching on the filename when
               retrieving entries in the zipfile via the string-based indexer.
             </summary>
            
             <remarks>
               The default value is <c>false</c>, which means don't do case-sensitive
               matching. In other words, retrieving zip["ReadMe.Txt"] is the same as
               zip["readme.txt"].  It really makes sense to set this to <c>true</c> only
               if you are not running on Windows, which has case-insensitive
               filenames. But since this library is not built for non-Windows platforms,
               in most cases you should just leave this property alone.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.UseUnicodeAsNecessary">
             <summary>
               Indicates whether to encode entry filenames and entry comments using Unicode
               (UTF-8).
             </summary>
            
             <remarks>
             <para>
               <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">The
               PKWare zip specification</see> provides for encoding file names and file
               comments in either the IBM437 code page, or in UTF-8.  This flag selects
               the encoding according to that specification.  By default, this flag is
               false, and filenames and comments are encoded into the zip file in the
               IBM437 codepage.  Setting this flag to true will specify that filenames
               and comments that cannot be encoded with IBM437 will be encoded with
               UTF-8.
             </para>
            
             <para>
               Zip files created with strict adherence to the PKWare specification with
               respect to UTF-8 encoding can contain entries with filenames containing
               any combination of Unicode characters, including the full range of
               characters from Chinese, Latin, Hebrew, Greek, Cyrillic, and many other
               alphabets.  However, because at this time, the UTF-8 portion of the PKWare
               specification is not broadly supported by other zip libraries and
               utilities, such zip files may not be readable by your favorite zip tool or
               archiver. In other words, interoperability will decrease if you set this
               flag to true.
             </para>
            
             <para>
               In particular, Zip files created with strict adherence to the PKWare
               specification with respect to UTF-8 encoding will not work well with
               Explorer in Windows XP or Windows Vista, because Windows compressed
               folders, as far as I know, do not support UTF-8 in zip files.  Vista can
               read the zip files, but shows the filenames incorrectly. Unpacking from
               Windows Vista Explorer will result in filenames that have rubbish
               characters in place of the high-order UTF-8 bytes.
             </para>
            
             <para>
               Also, zip files that use UTF-8 encoding will not work well with Java
               applications that use the java.util.zip classes, as of v5.0 of the Java
               runtime. The Java runtime does not correctly implement the PKWare
               specification in this regard.
             </para>
            
             <para>
               As a result, we have the unfortunate situation that "correct" behavior by
               the DotNetZip library with regard to Unicode encoding of filenames during
               zip creation will result in zip files that are readable by strictly
               compliant and current tools (for example the most recent release of the
               commercial WinZip tool); but these zip files will not be readable by
               various other tools or libraries, including Windows Explorer.
             </para>
            
             <para>
               The DotNetZip library can read and write zip files with UTF8-encoded
               entries, according to the PKware spec.  If you use DotNetZip for both
               creating and reading the zip file, and you use UTF-8, there will be no
               loss of information in the filenames. For example, using a self-extractor
               created by this library will allow you to unpack files correctly with no
               loss of information in the filenames.
             </para>
            
             <para>
               If you do not set this flag, it will remain false.  If this flag is false,
               your <c>ZipFile</c> will encode all filenames and comments using the
               IBM437 codepage.  This can cause "loss of information" on some filenames,
               but the resulting zipfile will be more interoperable with other
               utilities. As an example of the loss of information, diacritics can be
               lost.  The o-tilde character will be down-coded to plain o.  The c with a
               cedilla (Unicode 0xE7) used in Portugese will be downcoded to a c.
               Likewise, the O-stroke character (Unicode 248), used in Danish and
               Norwegian, will be down-coded to plain o. Chinese characters cannot be
               represented in codepage IBM437; when using the default encoding, Chinese
               characters in filenames will be represented as ?. These are all examples
               of "information loss".
             </para>
            
             <para>
               The loss of information associated to the use of the IBM437 encoding is
               inconvenient, and can also lead to runtime errors. For example, using
               IBM437, any sequence of 4 Chinese characters will be encoded as ????.  If
               your application creates a <c>ZipFile</c>, then adds two files, each with
               names of four Chinese characters each, this will result in a duplicate
               filename exception.  In the case where you add a single file with a name
               containing four Chinese characters, calling Extract() on the entry that
               has question marks in the filename will result in an exception, because
               the question mark is not legal for use within filenames on Windows.  These
               are just a few examples of the problems associated to loss of information.
             </para>
            
             <para>
               This flag is independent of the encoding of the content within the entries
               in the zip file. Think of the zip file as a container - it supports an
               encoding.  Within the container are other "containers" - the file entries
               themselves.  The encoding within those entries is independent of the
               encoding of the zip archive container for those entries.
             </para>
            
             <para>
               Rather than specify the encoding in a binary fashion using this flag, an
               application can specify an arbitrary encoding via the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/> property.  Setting the encoding
               explicitly when creating zip archives will result in non-compliant zip
               files that, curiously, are fairly interoperable.  The challenge is, the
               PKWare specification does not provide for a way to specify that an entry
               in a zip archive uses a code page that is neither IBM437 nor UTF-8.
               Therefore if you set the encoding explicitly when creating a zip archive,
               you must take care upon reading the zip archive to use the same code page.
               If you get it wrong, the behavior is undefined and may result in incorrect
               filenames, exceptions, stomach upset, hair loss, and acne.
             </para>
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.UseZip64WhenSaving">
             <summary>
               Specify whether to use ZIP64 extensions when saving a zip archive.
             </summary>
            
             <remarks>
            
             <para>
               When creating a zip file, the default value for the property is <see cref="F:Ionic.Zip.Zip64Option.Never"/>. <see cref="F:Ionic.Zip.Zip64Option.AsNecessary"/> is
               safest, in the sense that you will not get an Exception if a pre-ZIP64
               limit is exceeded.
             </para>
            
             <para>
               You may set the property at any time before calling Save().
             </para>
            
             <para>
               When reading a zip file via the <c>Zipfile.Read()</c> method, DotNetZip
               will properly read ZIP64-endowed zip archives, regardless of the value of
               this property.  DotNetZip will always read ZIP64 archives.  This property
               governs only whether DotNetZip will write them. Therefore, when updating
               archives, be careful about setting this property after reading an archive
               that may use ZIP64 extensions.
             </para>
            
             <para>
               An interesting question is, if you have set this property to
               <c>AsNecessary</c>, and then successfully saved, does the resulting
               archive use ZIP64 extensions or not?  To learn this, check the <see cref="P:Ionic.Zip.ZipFile.OutputUsedZip64"/> property, after calling <c>Save()</c>.
             </para>
            
             <para>
               Have you thought about
               <see href="http://cheeso.members.winisp.net/DotNetZipDonate.aspx">donating</see>?
             </para>
            
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipFile.RequiresZip64"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.RequiresZip64">
             <summary>
               Indicates whether the archive requires ZIP64 extensions.
             </summary>
            
             <remarks>
            
             <para>
               This property is <c>null</c> (or <c>Nothing</c> in VB) if the archive has
               not been saved, and there are fewer than 65334 <c>ZipEntry</c> items
               contained in the archive.
             </para>
            
             <para>
               The <c>Value</c> is true if any of the following four conditions holds:
               the uncompressed size of any entry is larger than 0xFFFFFFFF; the
               compressed size of any entry is larger than 0xFFFFFFFF; the relative
               offset of any entry within the zip archive is larger than 0xFFFFFFFF; or
               there are more than 65534 entries in the archive.  (0xFFFFFFFF =
               4,294,967,295).  The result may not be known until a <c>Save()</c> is attempted
               on the zip archive.  The Value of this <see cref="T:System.Nullable"/>
               property may be set only AFTER one of the Save() methods has been called.
             </para>
            
             <para>
               If none of the four conditions holds, and the archive has been saved, then
               the <c>Value</c> is false.
             </para>
            
             <para>
               A <c>Value</c> of false does not indicate that the zip archive, as saved,
               does not use ZIP64.  It merely indicates that ZIP64 is not required.  An
               archive may use ZIP64 even when not required if the <see cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving"/> property is set to <see cref="F:Ionic.Zip.Zip64Option.Always"/>, or if the <see cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving"/> property is set to <see cref="F:Ionic.Zip.Zip64Option.AsNecessary"/> and the output stream was not
               seekable. Use the <see cref="P:Ionic.Zip.ZipFile.OutputUsedZip64"/> property to determine if
               the most recent <c>Save()</c> method resulted in an archive that utilized
               the ZIP64 extensions.
             </para>
            
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving"/>
             <seealso cref="P:Ionic.Zip.ZipFile.OutputUsedZip64"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.OutputUsedZip64">
             <summary>
               Indicates whether the most recent <c>Save()</c> operation used ZIP64 extensions.
             </summary>
            
             <remarks>
             <para>
               The use of ZIP64 extensions within an archive is not always necessary, and
               for interoperability concerns, it may be desired to NOT use ZIP64 if
               possible.  The <see cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving"/> property can be
               set to use ZIP64 extensions only when necessary.  In those cases,
               Sometimes applications want to know whether a Save() actually used ZIP64
               extensions.  Applications can query this read-only property to learn
               whether ZIP64 has been used in a just-saved <c>ZipFile</c>.
             </para>
            
             <para>
               The value is <c>null</c> (or <c>Nothing</c> in VB) if the archive has not
               been saved.
             </para>
            
             <para>
               Non-null values (<c>HasValue</c> is true) indicate whether ZIP64
               extensions were used during the most recent <c>Save()</c> operation.  The
               ZIP64 extensions may have been used as required by any particular entry
               because of its uncompressed or compressed size, or because the archive is
               larger than 4294967295 bytes, or because there are more than 65534 entries
               in the archive, or because the <c>UseZip64WhenSaving</c> property was set
               to <see cref="F:Ionic.Zip.Zip64Option.Always"/>, or because the
               <c>UseZip64WhenSaving</c> property was set to <see cref="F:Ionic.Zip.Zip64Option.AsNecessary"/> and the output stream was not seekable.
               The value of this property does not indicate the reason the ZIP64
               extensions were used.
             </para>
            
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving"/>
             <seealso cref="P:Ionic.Zip.ZipFile.RequiresZip64"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.InputUsesZip64">
             <summary>
               Indicates whether the most recent <c>Read()</c> operation read a zip file that uses
               ZIP64 extensions.
             </summary>
            
             <remarks>
               This property will return null (Nothing in VB) if you've added an entry after reading
               the zip file.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding">
             <summary>
               The text encoding to use when writing new entries to the <c>ZipFile</c>,
               for those entries that cannot be encoded with the default (IBM437)
               encoding; or, the text encoding that was used when reading the entries
               from the <c>ZipFile</c>.
             </summary>
            
             <remarks>
             <para>
               In <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">its
               zip specification</see>, PKWare describes two options for encoding
               filenames and comments: using IBM437 or UTF-8.  But, some archiving tools
               or libraries do not follow the specification, and instead encode
               characters using the system default code page.  For example, WinRAR when
               run on a machine in Shanghai may encode filenames with the Big-5 Chinese
               (950) code page.  This behavior is contrary to the Zip specification, but
               it occurs anyway.
             </para>
            
             <para>
               When using DotNetZip to write zip archives that will be read by one of
               these other archivers, set this property to specify the code page to use
               when encoding the <see cref="P:Ionic.Zip.ZipEntry.FileName"/> and <see cref="P:Ionic.Zip.ZipEntry.Comment"/> for each <c>ZipEntry</c> in the zip file, for
               values that cannot be encoded with the default codepage for zip files,
               IBM437.  This is why this property is "provisional".  In all cases, IBM437
               is used where possible, in other words, where no loss of data would
               result. It is possible, therefore, to have a given entry with a
               <c>Comment</c> encoded in IBM437 and a <c>FileName</c> encoded with the
               specified "provisional" codepage.
             </para>
            
             <para>
               Be aware that a zip file created after you've explicitly set the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/> property to a value other than
               IBM437 may not be compliant to the PKWare specification, and may not be
               readable by compliant archivers.  On the other hand, many (most?)
               archivers are non-compliant and can read zip files created in arbitrary
               code pages.  The trick is to use or specify the proper codepage when
               reading the zip.
             </para>
            
             <para>
               When creating a zip archive using this library, it is possible to change
               the value of <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/> between each
               entry you add, and between adding entries and the call to
               <c>Save()</c>. Don't do this. It will likely result in a zipfile that is
               not readable.  For best interoperability, either leave <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/> alone, or specify it only once,
               before adding any entries to the <c>ZipFile</c> instance.  There is one
               exception to this recommendation, described later.
             </para>
            
             <para>
               When using an arbitrary, non-UTF8 code page for encoding, there is no
               standard way for the creator application - whether DotNetZip, WinZip,
               WinRar, or something else - to formally specify in the zip file which
               codepage has been used for the entries. As a result, readers of zip files
               are not able to inspect the zip file and determine the codepage that was
               used for the entries contained within it.  It is left to the application
               or user to determine the necessary codepage when reading zip files encoded
               this way.  In other words, if you explicitly specify the codepage when you
               create the zipfile, you must explicitly specify the same codepage when
               reading the zipfile.
             </para>
            
             <para>
               The way you specify the code page to use when reading a zip file varies
               depending on the tool or library you use to read the zip.  In DotNetZip,
               you use a ZipFile.Read() method that accepts an encoding parameter.  It
               isn't possible with Windows Explorer, as far as I know, to specify an
               explicit codepage to use when reading a zip.  If you use an incorrect
               codepage when reading a zipfile, you will get entries with filenames that
               are incorrect, and the incorrect filenames may even contain characters
               that are not legal for use within filenames in Windows. Extracting entries
               with illegal characters in the filenames will lead to exceptions. It's too
               bad, but this is just the way things are with code pages in zip
               files. Caveat Emptor.
             </para>
            
             <para>
               Example: Suppose you create a zipfile that contains entries with
               filenames that have Danish characters.  If you use <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/> equal to "iso-8859-1" (cp 28591),
               the filenames will be correctly encoded in the zip.  But, to read that
               zipfile correctly, you have to specify the same codepage at the time you
               read it. If try to read that zip file with Windows Explorer or another
               application that is not flexible with respect to the codepage used to
               decode filenames in zipfiles, you will get a filename like "Inf°.txt".
             </para>
            
             <para>
               When using DotNetZip to read a zip archive, and the zip archive uses an
               arbitrary code page, you must specify the encoding to use before or when
               the <c>Zipfile</c> is READ.  This means you must use a <c>ZipFile.Read()</c>
               method that allows you to specify a System.Text.Encoding parameter.  Setting
               the ProvisionalAlternateEncoding property after your application has read in
               the zip archive will not affect the entry names of entries that have already
               been read in.
             </para>
            
             <para>
               And now, the exception to the rule described above.  One strategy for
               specifying the code page for a given zip file is to describe the code page
               in a human-readable form in the Zip comment. For example, the comment may
               read "Entries in this archive are encoded in the Big5 code page".  For
               maximum interoperability, the zip comment in this case should be encoded
               in the default, IBM437 code page.  In this case, the zip comment is
               encoded using a different page than the filenames.  To do this, Specify
               <c>ProvisionalAlternateEncoding</c> to your desired region-specific code
               page, once before adding any entries, and then reset
               <c>ProvisionalAlternateEncoding</c> to IBM437 before setting the <see cref="P:Ionic.Zip.ZipFile.Comment"/> property and calling Save().
             </para>
             </remarks>
            
             <example>
             This example shows how to read a zip file using the Big-5 Chinese code page
             (950), and extract each entry in the zip file.  For this code to work as
             desired, the <c>Zipfile</c> must have been created using the big5 code page
             (CP950). This is typical, for example, when using WinRar on a machine with
             CP950 set as the default code page.  In that case, the names of entries
             within the Zip archive will be stored in that code page, and reading the zip
             archive must be done using that code page.  If the application did not use
             the correct code page in <c>ZipFile.Read()</c>, then names of entries within the
             zip archive would not be correctly retrieved.
             <code>
             using (var zip = ZipFile.Read(zipFileName, System.Text.Encoding.GetEncoding("big5")))
             {
                 // retrieve and extract an entry using a name encoded with CP950
                 zip[MyDesiredEntry].Extract("unpack");
             }
             </code>
            
             <code lang="VB">
             Using zip As ZipFile = ZipFile.Read(ZipToExtract, System.Text.Encoding.GetEncoding("big5"))
                 ' retrieve and extract an entry using a name encoded with CP950
                 zip(MyDesiredEntry).Extract("unpack")
             End Using
             </code>
             </example>
            
             <seealso cref="P:Ionic.Zip.ZipFile.DefaultEncoding">DefaultEncoding</seealso>
        </member>
        <member name="P:Ionic.Zip.ZipFile.AlternateEncoding">
            <summary>
              A Text Encoding to use when encoding the filenames and comments for
              all the ZipEntry items, during a ZipFile.Save() operation.
            </summary>
            <remarks>
              <para>
                Whether the encoding specified here is used during the save depends
                on <see cref="P:Ionic.Zip.ZipFile.AlternateEncodingUsage"/>.
              </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.AlternateEncodingUsage">
            <summary>
              A flag that tells if and when this instance should apply
              AlternateEncoding to encode the filenames and comments associated to
              of ZipEntry objects contained within this instance.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipFile.DefaultEncoding">
            <summary>
            The default text encoding used in zip archives.  It is numeric 437, also
            known as IBM437.
            </summary>
            <seealso cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.StatusMessageTextWriter">
             <summary>
             Gets or sets the <c>TextWriter</c> to which status messages are delivered
             for the instance.
             </summary>
            
             <remarks>
               If the TextWriter is set to a non-null value, then verbose output is sent
               to the <c>TextWriter</c> during <c>Add</c><c>, Read</c><c>, Save</c> and
               <c>Extract</c> operations.  Typically, console applications might use
               <c>Console.Out</c> and graphical or headless applications might use a
               <c>System.IO.StringWriter</c>. The output of this is suitable for viewing
               by humans.
             </remarks>
            
             <example>
             <para>
               In this example, a console application instantiates a <c>ZipFile</c>, then
               sets the <c>StatusMessageTextWriter</c> to <c>Console.Out</c>.  At that
               point, all verbose status messages for that <c>ZipFile</c> are sent to the
               console.
             </para>
            
             <code lang="C#">
             using (ZipFile zip= ZipFile.Read(FilePath))
             {
               zip.StatusMessageTextWriter= System.Console.Out;
               // messages are sent to the console during extraction
               zip.ExtractAll();
             }
             </code>
            
             <code lang="VB">
             Using zip As ZipFile = ZipFile.Read(FilePath)
               zip.StatusMessageTextWriter= System.Console.Out
               'Status Messages will be sent to the console during extraction
               zip.ExtractAll()
             End Using
             </code>
            
             <para>
               In this example, a Windows Forms application instantiates a
               <c>ZipFile</c>, then sets the <c>StatusMessageTextWriter</c> to a
               <c>StringWriter</c>.  At that point, all verbose status messages for that
               <c>ZipFile</c> are sent to the <c>StringWriter</c>.
             </para>
            
             <code lang="C#">
             var sw = new System.IO.StringWriter();
             using (ZipFile zip= ZipFile.Read(FilePath))
             {
               zip.StatusMessageTextWriter= sw;
               zip.ExtractAll();
             }
             Console.WriteLine("{0}", sw.ToString());
             </code>
            
             <code lang="VB">
             Dim sw as New System.IO.StringWriter
             Using zip As ZipFile = ZipFile.Read(FilePath)
               zip.StatusMessageTextWriter= sw
               zip.ExtractAll()
             End Using
             'Status Messages are now available in sw
            
             </code>
             </example>
        </member>
        <member name="P:Ionic.Zip.ZipFile.TempFileFolder">
             <summary>
               Gets or sets the name for the folder to store the temporary file
               this library writes when saving a zip archive.
             </summary>
            
             <remarks>
             <para>
               This library will create a temporary file when saving a Zip archive to a
               file.  This file is written when calling one of the <c>Save()</c> methods
               that does not save to a stream, or one of the <c>SaveSelfExtractor()</c>
               methods.
             </para>
            
             <para>
               By default, the library will create the temporary file in the directory
               specified for the file itself, via the <see cref="P:Ionic.Zip.ZipFile.Name"/> property or via
               the <see cref="M:Ionic.Zip.ZipFile.Save(System.String)"/> method.
             </para>
            
             <para>
               Setting this property allows applications to override this default
               behavior, so that the library will create the temporary file in the
               specified folder. For example, to have the library create the temporary
               file in the current working directory, regardless where the <c>ZipFile</c>
               is saved, specfy ".".  To revert to the default behavior, set this
               property to <c>null</c> (<c>Nothing</c> in VB).
             </para>
            
             <para>
               When setting the property to a non-null value, the folder specified must
               exist; if it does not an exception is thrown.  The application should have
               write and delete permissions on the folder.  The permissions are not
               explicitly checked ahead of time; if the application does not have the
               appropriate rights, an exception will be thrown at the time <c>Save()</c>
               is called.
             </para>
            
             <para>
               There is no temporary file created when reading a zip archive.  When
               saving to a Stream, there is no temporary file created.  For example, if
               the application is an ASP.NET application and calls <c>Save()</c>
               specifying the <c>Response.OutputStream</c> as the output stream, there is
               no temporary file created.
             </para>
             </remarks>
            
             <exception cref="T:System.IO.FileNotFoundException">
             Thrown when setting the property if the directory does not exist.
             </exception>
            
        </member>
        <member name="P:Ionic.Zip.ZipFile.Password">
             <summary>
             Sets the password to be used on the <c>ZipFile</c> instance.
             </summary>
            
             <remarks>
            
             <para>
               When writing a zip archive, this password is applied to the entries, not
               to the zip archive itself. It applies to any <c>ZipEntry</c> subsequently
               added to the <c>ZipFile</c>, using one of the <c>AddFile</c>,
               <c>AddDirectory</c>, <c>AddEntry</c>, or <c>AddItem</c> methods, etc.
               When reading a zip archive, this property applies to any entry
               subsequently extracted from the <c>ZipFile</c> using one of the Extract
               methods on the <c>ZipFile</c> class.
             </para>
            
             <para>
               When writing a zip archive, keep this in mind: though the password is set
               on the ZipFile object, according to the Zip spec, the "directory" of the
               archive - in other words the list of entries or files contained in the archive - is
               not encrypted with the password, or protected in any way.  If you set the
               Password property, the password actually applies to individual entries
               that are added to the archive, subsequent to the setting of this property.
               The list of filenames in the archive that is eventually created will
               appear in clear text, but the contents of the individual files are
               encrypted.  This is how Zip encryption works.
             </para>
            
             <para>
               One simple way around this limitation is to simply double-wrap sensitive
               filenames: Store the files in a zip file, and then store that zip file
               within a second, "outer" zip file.  If you apply a password to the outer
               zip file, then readers will be able to see that the outer zip file
               contains an inner zip file.  But readers will not be able to read the
               directory or file list of the inner zip file.
             </para>
            
             <para>
               If you set the password on the <c>ZipFile</c>, and then add a set of files
               to the archive, then each entry is encrypted with that password.  You may
               also want to change the password between adding different entries. If you
               set the password, add an entry, then set the password to <c>null</c>
               (<c>Nothing</c> in VB), and add another entry, the first entry is
               encrypted and the second is not.  If you call <c>AddFile()</c>, then set
               the <c>Password</c> property, then call <c>ZipFile.Save</c>, the file
               added will not be password-protected, and no warning will be generated.
             </para>
            
             <para>
               When setting the Password, you may also want to explicitly set the <see cref="P:Ionic.Zip.ZipFile.Encryption"/> property, to specify how to encrypt the entries added
               to the ZipFile.  If you set the Password to a non-null value and do not
               set <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, then PKZip 2.0 ("Weak") encryption is used.
               This encryption is relatively weak but is very interoperable. If you set
               the password to a <c>null</c> value (<c>Nothing</c> in VB), Encryption is
               reset to None.
             </para>
            
             <para>
               All of the preceding applies to writing zip archives, in other words when
               you use one of the Save methods.  To use this property when reading or an
               existing ZipFile, do the following: set the Password property on the
               <c>ZipFile</c>, then call one of the Extract() overloads on the <see cref="T:Ionic.Zip.ZipEntry"/>. In this case, the entry is extracted using the
               <c>Password</c> that is specified on the <c>ZipFile</c> instance. If you
               have not set the <c>Password</c> property, then the password is
               <c>null</c>, and the entry is extracted with no password.
             </para>
            
             <para>
               If you set the Password property on the <c>ZipFile</c>, then call
               <c>Extract()</c> an entry that has not been encrypted with a password, the
               password is not used for that entry, and the <c>ZipEntry</c> is extracted
               as normal. In other words, the password is used only if necessary.
             </para>
            
             <para>
               The <see cref="T:Ionic.Zip.ZipEntry"/> class also has a <see cref="P:Ionic.Zip.ZipEntry.Password">Password</see> property.  It takes precedence
               over this property on the <c>ZipFile</c>.  Typically, you would use the
               per-entry Password when most entries in the zip archive use one password,
               and a few entries use a different password.  If all entries in the zip
               file use the same password, then it is simpler to just set this property
               on the <c>ZipFile</c> itself, whether creating a zip archive or extracting
               a zip archive.
             </para>
            
             </remarks>
            
             <example>
             <para>
               This example creates a zip file, using password protection for the
               entries, and then extracts the entries from the zip file.  When creating
               the zip file, the Readme.txt file is not protected with a password, but
               the other two are password-protected as they are saved. During extraction,
               each file is extracted with the appropriate password.
             </para>
             <code>
             // create a file with encryption
             using (ZipFile zip = new ZipFile())
             {
                 zip.AddFile("ReadMe.txt");
                 zip.Password= "!Secret1";
                 zip.AddFile("MapToTheSite-7440-N49th.png");
                 zip.AddFile("2008-Regional-Sales-Report.pdf");
                 zip.Save("EncryptedArchive.zip");
             }
            
             // extract entries that use encryption
             using (ZipFile zip = ZipFile.Read("EncryptedArchive.zip"))
             {
                 zip.Password= "!Secret1";
                 zip.ExtractAll("extractDir");
             }
            
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile
                 zip.AddFile("ReadMe.txt")
                 zip.Password = "123456!"
                 zip.AddFile("MapToTheSite-7440-N49th.png")
                 zip.Password= "!Secret1";
                 zip.AddFile("2008-Regional-Sales-Report.pdf")
                 zip.Save("EncryptedArchive.zip")
             End Using
            
            
             ' extract entries that use encryption
             Using (zip as ZipFile = ZipFile.Read("EncryptedArchive.zip"))
                 zip.Password= "!Secret1"
                 zip.ExtractAll("extractDir")
             End Using
            
             </code>
            
             </example>
            
             <seealso cref="P:Ionic.Zip.ZipFile.Encryption">ZipFile.Encryption</seealso>
             <seealso cref="P:Ionic.Zip.ZipEntry.Password">ZipEntry.Password</seealso>
        </member>
        <member name="P:Ionic.Zip.ZipFile.ExtractExistingFile">
             <summary>
               The action the library should take when extracting a file that already
               exists.
             </summary>
            
             <remarks>
             <para>
               This property affects the behavior of the Extract methods (one of the
               <c>Extract()</c> or <c>ExtractWithPassword()</c> overloads), when
               extraction would would overwrite an existing filesystem file. If you do
               not set this property, the library throws an exception when extracting an
               entry would overwrite an existing file.
             </para>
            
             <para>
               This property has no effect when extracting to a stream, or when the file
               to be extracted does not already exist.
             </para>
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.ZipErrorAction">
             <summary>
               The action the library should take when an error is encountered while
               opening or reading files as they are saved into a zip archive.
             </summary>
            
             <remarks>
              <para>
                Errors can occur as a file is being saved to the zip archive.  For
                example, the File.Open may fail, or a File.Read may fail, because of
                lock conflicts or other reasons.
              </para>
            
              <para>
                The first problem might occur after having called AddDirectory() on a
                directory that contains a Clipper .dbf file; the file is locked by
                Clipper and cannot be opened for read by another process. An example of
                the second problem might occur when trying to zip a .pst file that is in
                use by Microsoft Outlook. Outlook locks a range on the file, which allows
                other processes to open the file, but not read it in its entirety.
              </para>
            
              <para>
                This property tells DotNetZip what you would like to do in the case of
                these errors.  The primary options are: <c>ZipErrorAction.Throw</c> to
                throw an exception (this is the default behavior if you don't set this
                property); <c>ZipErrorAction.Skip</c> to Skip the file for which there
                was an error and continue saving; <c>ZipErrorAction.Retry</c> to Retry
                the entry that caused the problem; or
                <c>ZipErrorAction.InvokeErrorEvent</c> to invoke an event handler.
              </para>
            
              <para>
                This property is implicitly set to <c>ZipErrorAction.InvokeErrorEvent</c>
                if you add a handler to the <see cref="E:Ionic.Zip.ZipFile.ZipError"/> event.  If you set
                this property to something other than
                <c>ZipErrorAction.InvokeErrorEvent</c>, then the <c>ZipError</c>
                event is implicitly cleared.  What it means is you can set one or the
                other (or neither), depending on what you want, but you never need to set
                both.
              </para>
            
              <para>
                As with some other properties on the <c>ZipFile</c> class, like <see cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, setting this property on a <c>ZipFile</c>
                instance will cause the specified <c>ZipErrorAction</c> to be used on all
                <see cref="T:Ionic.Zip.ZipEntry"/> items that are subsequently added to the
                <c>ZipFile</c> instance. If you set this property after you have added
                items to the <c>ZipFile</c>, but before you have called <c>Save()</c>,
                those items will not use the specified error handling action.
              </para>
            
              <para>
                If you want to handle any errors that occur with any entry in the zip
                file in the same way, then set this property once, before adding any
                entries to the zip archive.
              </para>
            
              <para>
                If you set this property to <c>ZipErrorAction.Skip</c> and you'd like to
                learn which files may have been skipped after a <c>Save()</c>, you can
                set the <see cref="P:Ionic.Zip.ZipFile.StatusMessageTextWriter"/> on the ZipFile before
                calling <c>Save()</c>. A message will be emitted into that writer for
                each skipped file, if any.
              </para>
            
             </remarks>
            
             <example>
               This example shows how to tell DotNetZip to skip any files for which an
               error is generated during the Save().
             <code lang="VB">
             Public Sub SaveZipFile()
                 Dim SourceFolder As String = "fodder"
                 Dim DestFile As String =  "eHandler.zip"
                 Dim sw as New StringWriter
                 Using zipArchive As ZipFile = New ZipFile
                     ' Tell DotNetZip to skip any files for which it encounters an error
                     zipArchive.ZipErrorAction = ZipErrorAction.Skip
                     zipArchive.StatusMessageTextWriter = sw
                     zipArchive.AddDirectory(SourceFolder)
                     zipArchive.Save(DestFile)
                 End Using
                 ' examine sw here to see any messages
             End Sub
            
             </code>
             </example>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.ZipErrorAction"/>
             <seealso cref="E:Ionic.Zip.ZipFile.ZipError"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.Encryption">
             <summary>
               The Encryption to use for entries added to the <c>ZipFile</c>.
             </summary>
            
             <remarks>
             <para>
               Set this when creating a zip archive, or when updating a zip archive. The
               specified Encryption is applied to the entries subsequently added to the
               <c>ZipFile</c> instance.  Applications do not need to set the
               <c>Encryption</c> property when reading or extracting a zip archive.
             </para>
            
             <para>
               If you set this to something other than EncryptionAlgorithm.None, you
               will also need to set the <see cref="P:Ionic.Zip.ZipFile.Password"/>.
             </para>
            
             <para>
               As with some other properties on the <c>ZipFile</c> class, like <see cref="P:Ionic.Zip.ZipFile.Password"/> and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, setting this
               property on a <c>ZipFile</c> instance will cause the specified
               <c>EncryptionAlgorithm</c> to be used on all <see cref="T:Ionic.Zip.ZipEntry"/> items
               that are subsequently added to the <c>ZipFile</c> instance. In other
               words, if you set this property after you have added items to the
               <c>ZipFile</c>, but before you have called <c>Save()</c>, those items will
               not be encrypted or protected with a password in the resulting zip
               archive. To get a zip archive with encrypted entries, set this property,
               along with the <see cref="P:Ionic.Zip.ZipFile.Password"/> property, before calling
               <c>AddFile</c>, <c>AddItem</c>, or <c>AddDirectory</c> (etc.) on the
               <c>ZipFile</c> instance.
             </para>
            
             <para>
               If you read a <c>ZipFile</c>, you can modify the <c>Encryption</c> on an
               encrypted entry, only by setting the <c>Encryption</c> property on the
               <c>ZipEntry</c> itself.  Setting the <c>Encryption</c> property on the
               <c>ZipFile</c>, once it has been created via a call to
               <c>ZipFile.Read()</c>, does not affect entries that were previously read.
             </para>
            
             <para>
               For example, suppose you read a <c>ZipFile</c>, and there is an encrypted
               entry.  Setting the <c>Encryption</c> property on that <c>ZipFile</c> and
               then calling <c>Save()</c> on the <c>ZipFile</c> does not update the
               <c>Encryption</c> used for the entries in the archive.  Neither is an
               exception thrown. Instead, what happens during the <c>Save()</c> is that
               all previously existing entries are copied through to the new zip archive,
               with whatever encryption and password that was used when originally
               creating the zip archive. Upon re-reading that archive, to extract
               entries, applications should use the original password or passwords, if
               any.
             </para>
            
             <para>
               Suppose an application reads a <c>ZipFile</c>, and there is an encrypted
               entry.  Setting the <c>Encryption</c> property on that <c>ZipFile</c> and
               then adding new entries (via <c>AddFile()</c>, <c>AddEntry()</c>, etc)
               and then calling <c>Save()</c> on the <c>ZipFile</c> does not update the
               <c>Encryption</c> on any of the entries that had previously been in the
               <c>ZipFile</c>.  The <c>Encryption</c> property applies only to the
               newly-added entries.
             </para>
            
             </remarks>
            
             <example>
             <para>
               This example creates a zip archive that uses encryption, and then extracts
               entries from the archive.  When creating the zip archive, the ReadMe.txt
               file is zipped without using a password or encryption.  The other files
               use encryption.
             </para>
            
             <code>
             // Create a zip archive with AES Encryption.
             using (ZipFile zip = new ZipFile())
             {
                 zip.AddFile("ReadMe.txt");
                 zip.Encryption= EncryptionAlgorithm.WinZipAes256;
                 zip.Password= "Top.Secret.No.Peeking!";
                 zip.AddFile("7440-N49th.png");
                 zip.AddFile("2008-Regional-Sales-Report.pdf");
                 zip.Save("EncryptedArchive.zip");
             }
            
             // Extract a zip archive that uses AES Encryption.
             // You do not need to specify the algorithm during extraction.
             using (ZipFile zip = ZipFile.Read("EncryptedArchive.zip"))
             {
                 zip.Password= "Top.Secret.No.Peeking!";
                 zip.ExtractAll("extractDirectory");
             }
             </code>
            
             <code lang="VB">
             ' Create a zip that uses Encryption.
             Using zip As New ZipFile()
                 zip.Encryption= EncryptionAlgorithm.WinZipAes256
                 zip.Password= "Top.Secret.No.Peeking!"
                 zip.AddFile("ReadMe.txt")
                 zip.AddFile("7440-N49th.png")
                 zip.AddFile("2008-Regional-Sales-Report.pdf")
                 zip.Save("EncryptedArchive.zip")
             End Using
            
             ' Extract a zip archive that uses AES Encryption.
             ' You do not need to specify the algorithm during extraction.
             Using (zip as ZipFile = ZipFile.Read("EncryptedArchive.zip"))
                 zip.Password= "Top.Secret.No.Peeking!"
                 zip.ExtractAll("extractDirectory")
             End Using
             </code>
            
             </example>
            
             <seealso cref="P:Ionic.Zip.ZipFile.Password">ZipFile.Password</seealso>
             <seealso cref="P:Ionic.Zip.ZipEntry.Encryption">ZipEntry.Encryption</seealso>
        </member>
        <member name="P:Ionic.Zip.ZipFile.SetCompression">
             <summary>
               A callback that allows the application to specify the compression level
               to use for entries subsequently added to the zip archive.
             </summary>
            
             <remarks>
            
             <para>
               With this callback, the DotNetZip library allows the application to
               determine whether compression will be used, at the time of the
               <c>Save</c>. This may be useful if the application wants to favor
               speed over size, and wants to defer the decision until the time of
               <c>Save</c>.
             </para>
            
             <para>
               Typically applications set the <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/> property on
               the <c>ZipFile</c> or on each <c>ZipEntry</c> to determine the level of
               compression used. This is done at the time the entry is added to the
               <c>ZipFile</c>. Setting the property to
               <c>Ionic.Zlib.CompressionLevel.None</c> means no compression will be used.
             </para>
            
             <para>
               This callback allows the application to defer the decision on the
               <c>CompressionLevel</c> to use, until the time of the call to
               <c>ZipFile.Save()</c>. The callback is invoked once per <c>ZipEntry</c>,
               at the time the data for the entry is being written out as part of a
               <c>Save()</c> operation. The application can use whatever criteria it
               likes in determining the level to return.  For example, an application may
               wish that no .mp3 files should be compressed, because they are already
               compressed and the extra compression is not worth the CPU time incurred,
               and so can return <c>None</c> for all .mp3 entries.
             </para>
            
             <para>
               The library determines whether compression will be attempted for an entry
               this way: If the entry is a zero length file, or a directory, no
               compression is used.  Otherwise, if this callback is set, it is invoked
               and the <c>CompressionLevel</c> is set to the return value. If this
               callback has not been set, then the previously set value for
               <c>CompressionLevel</c> is used.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.MaxOutputSegmentSize">
             <summary>
             The maximum size of an output segment, when saving a split Zip file.
             </summary>
             <remarks>
               <para>
                 Set this to a non-zero value before calling <see cref="M:Ionic.Zip.ZipFile.Save"/> or <see cref="M:Ionic.Zip.ZipFile.Save(System.String)"/> to specify that the ZipFile should be saved as a
                 split archive, also sometimes called a spanned archive. Some also
                 call them multi-file archives.
               </para>
            
               <para>
                 A split zip archive is saved in a set of discrete filesystem files,
                 rather than in a single file. This is handy when transmitting the
                 archive in email or some other mechanism that has a limit to the size of
                 each file.  The first file in a split archive will be named
                 <c>basename.z01</c>, the second will be named <c>basename.z02</c>, and
                 so on. The final file is named <c>basename.zip</c>. According to the zip
                 specification from PKWare, the minimum value is 65536, for a 64k segment
                 size. The maximum number of segments allows in a split archive is 99.
               </para>
            
               <para>
                 The value of this property determines the maximum size of a split
                 segment when writing a split archive.  For example, suppose you have a
                 <c>ZipFile</c> that would save to a single file of 200k. If you set the
                 <c>MaxOutputSegmentSize</c> to 65536 before calling <c>Save()</c>, you
                 will get four distinct output files. On the other hand if you set this
                 property to 256k, then you will get a single-file archive for that
                 <c>ZipFile</c>.
               </para>
            
               <para>
                 The size of each split output file will be as large as possible, up to
                 the maximum size set here. The zip specification requires that some data
                 fields in a zip archive may not span a split boundary, and an output
                 segment may be smaller than the maximum if necessary to avoid that
                 problem. Also, obviously the final segment of the archive may be smaller
                 than the maximum segment size. Segments will never be larger than the
                 value set with this property.
               </para>
            
               <para>
                 You can save a split Zip file only when saving to a regular filesystem
                 file. It's not possible to save a split zip file as a self-extracting
                 archive, nor is it possible to save a split zip file to a stream. When
                 saving to a SFX or to a Stream, this property is ignored.
               </para>
            
               <para>
                 About interoperability: Split or spanned zip files produced by DotNetZip
                 can be read by WinZip or PKZip, and vice-versa. Segmented zip files may
                 not be readable by other tools, if those other tools don't support zip
                 spanning or splitting.  When in doubt, test.  I don't believe Windows
                 Explorer can extract a split archive.
               </para>
            
               <para>
                 This property has no effect when reading a split archive. You can read
                 a split archive in the normal way with DotNetZip.
               </para>
            
               <para>
                 When saving a zip file, if you want a regular zip file rather than a
                 split zip file, don't set this property, or set it to Zero.
               </para>
            
               <para>
                 If you read a split archive, with <see cref="M:Ionic.Zip.ZipFile.Read(System.String)"/> and
                 then subsequently call <c>ZipFile.Save()</c>, unless you set this
                 property before calling <c>Save()</c>, you will get a normal,
                 single-file archive.
               </para>
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipFile.NumberOfSegmentsForMostRecentSave"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.NumberOfSegmentsForMostRecentSave">
            <summary>
              Returns the number of segments used in the most recent Save() operation.
            </summary>
            <remarks>
              <para>
                This is normally zero, unless you have set the <see cref="P:Ionic.Zip.ZipFile.MaxOutputSegmentSize"/> property.  If you have set <see cref="P:Ionic.Zip.ZipFile.MaxOutputSegmentSize"/>, and then you save a file, after the call to
                Save() completes, you can read this value to learn the number of segments that
                were created.
              </para>
              <para>
                If you call Save("Archive.zip"), and it creates 5 segments, then you
                will have filesystem files named Archive.z01, Archive.z02, Archive.z03,
                Archive.z04, and Archive.zip, and the value of this property will be 5.
              </para>
            </remarks>
            <seealso cref="P:Ionic.Zip.ZipFile.MaxOutputSegmentSize"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.ParallelDeflateThreshold">
             <summary>
               The size threshold for an entry, above which a parallel deflate is used.
             </summary>
            
             <remarks>
            
               <para>
                 DotNetZip will use multiple threads to compress any ZipEntry,
                 if the entry is larger than the given size.  Zero means "always
                 use parallel deflate", while -1 means "never use parallel
                 deflate". The default value for this property is 512k. Aside
                 from the special values of 0 and 1, the minimum value is 65536.
               </para>
            
               <para>
                 If the entry size cannot be known before compression, as with a
                 read-forward stream, then Parallel deflate will never be
                 performed, unless the value of this property is zero.
               </para>
            
               <para>
                 A parallel deflate operations will speed up the compression of
                 large files, on computers with multiple CPUs or multiple CPU
                 cores.  For files above 1mb, on a dual core or dual-cpu (2p)
                 machine, the time required to compress the file can be 70% of the
                 single-threaded deflate.  For very large files on 4p machines the
                 compression can be done in 30% of the normal time.  The downside
                 is that parallel deflate consumes extra memory during the deflate,
                 and the deflation is not as effective.
               </para>
            
               <para>
                 Parallel deflate tends to yield slightly less compression when
                 compared to as single-threaded deflate; this is because the original
                 data stream is split into multiple independent buffers, each of which
                 is compressed in parallel.  But because they are treated
                 independently, there is no opportunity to share compression
                 dictionaries.  For that reason, a deflated stream may be slightly
                 larger when compressed using parallel deflate, as compared to a
                 traditional single-threaded deflate. Sometimes the increase over the
                 normal deflate is as much as 5% of the total compressed size. For
                 larger files it can be as small as 0.1%.
               </para>
            
               <para>
                 Multi-threaded compression does not give as much an advantage when
                 using Encryption. This is primarily because encryption tends to slow
                 down the entire pipeline. Also, multi-threaded compression gives less
                 of an advantage when using lower compression levels, for example <see cref="F:Ionic.Zlib.CompressionLevel.BestSpeed"/>.  You may have to
                 perform some tests to determine the best approach for your situation.
               </para>
            
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipFile.ParallelDeflateMaxBufferPairs"/>
            
        </member>
        <member name="P:Ionic.Zip.ZipFile.ParallelDeflateMaxBufferPairs">
             <summary>
               The maximum number of buffer pairs to use when performing
               parallel compression.
             </summary>
            
             <remarks>
             <para>
               This property sets an upper limit on the number of memory
               buffer pairs to create when performing parallel
               compression.  The implementation of the parallel
               compression stream allocates multiple buffers to
               facilitate parallel compression.  As each buffer fills up,
               the stream uses <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)">
               ThreadPool.QueueUserWorkItem()</see> to compress those
               buffers in a background threadpool thread. After a buffer
               is compressed, it is re-ordered and written to the output
               stream.
             </para>
            
             <para>
               A higher number of buffer pairs enables a higher degree of
               parallelism, which tends to increase the speed of compression on
               multi-cpu computers.  On the other hand, a higher number of buffer
               pairs also implies a larger memory consumption, more active worker
               threads, and a higher cpu utilization for any compression. This
               property enables the application to limit its memory consumption and
               CPU utilization behavior depending on requirements.
             </para>
            
             <para>
               For each compression "task" that occurs in parallel, there are 2
               buffers allocated: one for input and one for output.  This property
               sets a limit for the number of pairs.  The total amount of storage
               space allocated for buffering will then be (N*S*2), where N is the
               number of buffer pairs, S is the size of each buffer (<see cref="P:Ionic.Zip.ZipFile.BufferSize"/>).  By default, DotNetZip allocates 4 buffer
               pairs per CPU core, so if your machine has 4 cores, and you retain
               the default buffer size of 128k, then the
               ParallelDeflateOutputStream will use 4 * 4 * 2 * 128kb of buffer
               memory in total, or 4mb, in blocks of 128kb.  If you then set this
               property to 8, then the number will be 8 * 2 * 128kb of buffer
               memory, or 2mb.
             </para>
            
             <para>
               CPU utilization will also go up with additional buffers, because a
               larger number of buffer pairs allows a larger number of background
               threads to compress in parallel. If you find that parallel
               compression is consuming too much memory or CPU, you can adjust this
               value downward.
             </para>
            
             <para>
               The default value is 16. Different values may deliver better or
               worse results, depending on your priorities and the dynamic
               performance characteristics of your storage and compute resources.
             </para>
            
             <para>
               This property is not the number of buffer pairs to use; it is an
               upper limit. An illustration: Suppose you have an application that
               uses the default value of this property (which is 16), and it runs
               on a machine with 2 CPU cores. In that case, DotNetZip will allocate
               4 buffer pairs per CPU core, for a total of 8 pairs.  The upper
               limit specified by this property has no effect.
             </para>
            
             <para>
               The application can set this value at any time
               before calling <c>ZipFile.Save()</c>.
             </para>
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipFile.ParallelDeflateThreshold"/>
            
        </member>
        <member name="P:Ionic.Zip.ZipFile.LibraryVersion">
             <summary>
             Returns the version number on the DotNetZip assembly.
             </summary>
            
             <remarks>
               <para>
                 This property is exposed as a convenience.  Callers could also get the
                 version value by retrieving GetName().Version on the
                 System.Reflection.Assembly object pointing to the DotNetZip
                 assembly. But sometimes it is not clear which assembly is being loaded.
                 This property makes it clear.
               </para>
               <para>
                 This static property is primarily useful for diagnostic purposes.
               </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.Item(System.Int32)">
             <summary>
               This is an integer indexer into the Zip archive.
             </summary>
            
             <remarks>
             <para>
               This property is read-only.
             </para>
            
             <para>
               Internally, the <c>ZipEntry</c> instances that belong to the
               <c>ZipFile</c> are stored in a Dictionary.  When you use this
               indexer the first time, it creates a read-only
               <c>List&lt;ZipEntry&gt;</c> from the Dictionary.Values Collection.
               If at any time you modify the set of entries in the <c>ZipFile</c>,
               either by adding an entry, removing an entry, or renaming an
               entry, a new List will be created, and the numeric indexes for the
               remaining entries may be different.
             </para>
            
             <para>
               This means you cannot rename any ZipEntry from
               inside an enumeration of the zip file.
             </para>
            
             <param name="ix">
               The index value.
             </param>
            
             </remarks>
            
             <returns>
               The <c>ZipEntry</c> within the Zip archive at the specified index. If the
               entry does not exist in the archive, this indexer throws.
             </returns>
            
        </member>
        <member name="P:Ionic.Zip.ZipFile.Item(System.String)">
             <summary>
               This is a name-based indexer into the Zip archive.
             </summary>
            
             <remarks>
             <para>
               This property is read-only.
             </para>
            
             <para>
               The <see cref="P:Ionic.Zip.ZipFile.CaseSensitiveRetrieval"/> property on the <c>ZipFile</c>
               determines whether retrieval via this indexer is done via case-sensitive
               comparisons. By default, retrieval is not case sensitive.  This makes
               sense on Windows, in which filesystems are not case sensitive.
             </para>
            
             <para>
               Regardless of case-sensitivity, it is not always the case that
               <c>this[value].FileName == value</c>. In other words, the <c>FileName</c>
               property of the <c>ZipEntry</c> retrieved with this indexer, may or may
               not be equal to the index value.
             </para>
            
             <para>
               This is because DotNetZip performs a normalization of filenames passed to
               this indexer, before attempting to retrieve the item.  That normalization
               includes: removal of a volume letter and colon, swapping backward slashes
               for forward slashes.  So, <c>zip["dir1\\entry1.txt"].FileName ==
               "dir1/entry.txt"</c>.
             </para>
            
             <para>
               Directory entries in the zip file may be retrieved via this indexer only
               with names that have a trailing slash. DotNetZip automatically appends a
               trailing slash to the names of any directory entries added to a zip.
             </para>
            
             </remarks>
            
             <example>
             This example extracts only the entries in a zip file that are .txt files.
             <code>
             using (ZipFile zip = ZipFile.Read("PackedDocuments.zip"))
             {
               foreach (string s1 in zip.EntryFilenames)
               {
                 if (s1.EndsWith(".txt"))
                   zip[s1].Extract("textfiles");
               }
             }
             </code>
             <code lang="VB">
               Using zip As ZipFile = ZipFile.Read("PackedDocuments.zip")
                   Dim s1 As String
                   For Each s1 In zip.EntryFilenames
                       If s1.EndsWith(".txt") Then
                           zip(s1).Extract("textfiles")
                       End If
                   Next
               End Using
             </code>
             </example>
             <seealso cref="M:Ionic.Zip.ZipFile.RemoveEntry(System.String)"/>
            
             <exception cref="T:System.ArgumentException">
               Thrown if the caller attempts to assign a non-null value to the indexer.
             </exception>
            
             <param name="fileName">
               The name of the file, including any directory path, to retrieve from the
               zip.  The filename match is not case-sensitive by default; you can use the
               <see cref="P:Ionic.Zip.ZipFile.CaseSensitiveRetrieval"/> property to change this behavior. The
               pathname can use forward-slashes or backward slashes.
             </param>
            
             <returns>
               The <c>ZipEntry</c> within the Zip archive, given by the specified
               filename. If the named entry does not exist in the archive, this indexer
               returns <c>null</c> (<c>Nothing</c> in VB).
             </returns>
            
        </member>
        <member name="P:Ionic.Zip.ZipFile.EntryFileNames">
             <summary>
               The list of filenames for the entries contained within the zip archive.
             </summary>
            
             <remarks>
               According to the ZIP specification, the names of the entries use forward
               slashes in pathnames.  If you are scanning through the list, you may have
               to swap forward slashes for backslashes.
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipFile.Item(System.String)"/>
            
             <example>
               This example shows one way to test if a filename is already contained
               within a zip archive.
             <code>
             String zipFileToRead= "PackedDocuments.zip";
             string candidate = "DatedMaterial.xps";
             using (ZipFile zip = new ZipFile(zipFileToRead))
             {
               if (zip.EntryFilenames.Contains(candidate))
                 Console.WriteLine("The file '{0}' exists in the zip archive '{1}'",
                                   candidate,
                                   zipFileName);
               else
                 Console.WriteLine("The file, '{0}', does not exist in the zip archive '{1}'",
                                   candidate,
                                   zipFileName);
               Console.WriteLine();
             }
             </code>
             <code lang="VB">
               Dim zipFileToRead As String = "PackedDocuments.zip"
               Dim candidate As String = "DatedMaterial.xps"
               Using zip As ZipFile.Read(ZipFileToRead)
                   If zip.EntryFilenames.Contains(candidate) Then
                       Console.WriteLine("The file '{0}' exists in the zip archive '{1}'", _
                                   candidate, _
                                   zipFileName)
                   Else
                     Console.WriteLine("The file, '{0}', does not exist in the zip archive '{1}'", _
                                   candidate, _
                                   zipFileName)
                   End If
                   Console.WriteLine
               End Using
             </code>
             </example>
            
             <returns>
               The list of strings for the filenames contained within the Zip archive.
             </returns>
            
        </member>
        <member name="P:Ionic.Zip.ZipFile.Entries">
             <summary>
               Returns the readonly collection of entries in the Zip archive.
             </summary>
            
             <remarks>
            
             <para>
               If there are no entries in the current <c>ZipFile</c>, the value returned is a
               non-null zero-element collection.  If there are entries in the zip file,
               the elements are returned in no particular order.
             </para>
             <para>
               This is the implied enumerator on the <c>ZipFile</c> class.  If you use a
               <c>ZipFile</c> instance in a context that expects an enumerator, you will
               get this collection.
             </para>
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipFile.EntriesSorted"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.EntriesSorted">
             <summary>
               Returns a readonly collection of entries in the Zip archive, sorted by FileName.
             </summary>
            
             <remarks>
               If there are no entries in the current <c>ZipFile</c>, the value returned
               is a non-null zero-element collection.  If there are entries in the zip
               file, the elements are returned sorted by the name of the entry.
             </remarks>
            
             <example>
            
               This example fills a Windows Forms ListView with the entries in a zip file.
            
             <code lang="C#">
             using (ZipFile zip = ZipFile.Read(zipFile))
             {
                 foreach (ZipEntry entry in zip.EntriesSorted)
                 {
                     ListViewItem item = new ListViewItem(n.ToString());
                     n++;
                     string[] subitems = new string[] {
                         entry.FileName.Replace("/","\\"),
                         entry.LastModified.ToString("yyyy-MM-dd HH:mm:ss"),
                         entry.UncompressedSize.ToString(),
                         String.Format("{0,5:F0}%", entry.CompressionRatio),
                         entry.CompressedSize.ToString(),
                         (entry.UsesEncryption) ? "Y" : "N",
                         String.Format("{0:X8}", entry.Crc)};
            
                     foreach (String s in subitems)
                     {
                         ListViewItem.ListViewSubItem subitem = new ListViewItem.ListViewSubItem();
                         subitem.Text = s;
                         item.SubItems.Add(subitem);
                     }
            
                     this.listView1.Items.Add(item);
                 }
             }
             </code>
             </example>
            
             <seealso cref="P:Ionic.Zip.ZipFile.Entries"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.Count">
            <summary>
            Returns the number of entries in the Zip archive.
            </summary>
        </member>
        <member name="E:Ionic.Zip.ZipFile.SaveProgress">
             <summary>
               An event handler invoked when a Save() starts, before and after each
               entry has been written to the archive, when a Save() completes, and
               during other Save events.
             </summary>
            
             <remarks>
             <para>
               Depending on the particular event, different properties on the <see cref="T:Ionic.Zip.SaveProgressEventArgs"/> parameter are set.  The following
               table summarizes the available EventTypes and the conditions under
               which this event handler is invoked with a
               <c>SaveProgressEventArgs</c> with the given EventType.
             </para>
            
             <list type="table">
             <listheader>
             <term>value of EntryType</term>
             <description>Meaning and conditions</description>
             </listheader>
            
             <item>
             <term>ZipProgressEventType.Saving_Started</term>
             <description>Fired when ZipFile.Save() begins.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Saving_BeforeSaveEntry</term>
             <description>
               Fired within ZipFile.Save(), just before writing data for each
               particular entry.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Saving_AfterSaveEntry</term>
             <description>
               Fired within ZipFile.Save(), just after having finished writing data
               for each particular entry.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Saving_Completed</term>
             <description>Fired when ZipFile.Save() has completed.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Saving_AfterSaveTempArchive</term>
             <description>
               Fired after the temporary file has been created.  This happens only
               when saving to a disk file.  This event will not be invoked when
               saving to a stream.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Saving_BeforeRenameTempArchive</term>
             <description>
               Fired just before renaming the temporary file to the permanent
               location.  This happens only when saving to a disk file.  This event
               will not be invoked when saving to a stream.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Saving_AfterRenameTempArchive</term>
             <description>
               Fired just after renaming the temporary file to the permanent
               location.  This happens only when saving to a disk file.  This event
               will not be invoked when saving to a stream.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Saving_AfterCompileSelfExtractor</term>
             <description>
               Fired after a self-extracting archive has finished compiling.  This
               EventType is used only within SaveSelfExtractor().
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Saving_BytesRead</term>
             <description>
               Set during the save of a particular entry, to update progress of the
               Save().  When this EventType is set, the BytesTransferred is the
               number of bytes that have been read from the source stream.  The
               TotalBytesToTransfer is the number of bytes in the uncompressed
               file.
             </description>
             </item>
            
             </list>
             </remarks>
            
             <example>
            
                This example uses an anonymous method to handle the
                SaveProgress event, by updating a progress bar.
            
             <code lang="C#">
             progressBar1.Value = 0;
             progressBar1.Max = listbox1.Items.Count;
             using (ZipFile zip = new ZipFile())
             {
                // listbox1 contains a list of filenames
                zip.AddFiles(listbox1.Items);
            
                // do the progress bar:
                zip.SaveProgress += (sender, e) =&gt; {
                   if (e.EventType == ZipProgressEventType.Saving_BeforeWriteEntry) {
                      progressBar1.PerformStep();
                   }
                };
            
                zip.Save(fs);
             }
             </code>
             </example>
            
             <example>
               This example uses a named method as the
               <c>SaveProgress</c> event handler, to update the user, in a
               console-based application.
            
             <code lang="C#">
             static bool justHadByteUpdate= false;
             public static void SaveProgress(object sender, SaveProgressEventArgs e)
             {
                 if (e.EventType == ZipProgressEventType.Saving_Started)
                     Console.WriteLine("Saving: {0}", e.ArchiveName);
            
                 else if (e.EventType == ZipProgressEventType.Saving_Completed)
                 {
                     justHadByteUpdate= false;
                     Console.WriteLine();
                     Console.WriteLine("Done: {0}", e.ArchiveName);
                 }
            
                 else if (e.EventType == ZipProgressEventType.Saving_BeforeWriteEntry)
                 {
                     if (justHadByteUpdate)
                         Console.WriteLine();
                     Console.WriteLine("  Writing: {0} ({1}/{2})",
                                       e.CurrentEntry.FileName, e.EntriesSaved, e.EntriesTotal);
                     justHadByteUpdate= false;
                 }
            
                 else if (e.EventType == ZipProgressEventType.Saving_EntryBytesRead)
                 {
                     if (justHadByteUpdate)
                         Console.SetCursorPosition(0, Console.CursorTop);
                      Console.Write("     {0}/{1} ({2:N0}%)", e.BytesTransferred, e.TotalBytesToTransfer,
                                   e.BytesTransferred / (0.01 * e.TotalBytesToTransfer ));
                     justHadByteUpdate= true;
                 }
             }
            
             public static ZipUp(string targetZip, string directory)
             {
               using (var zip = new ZipFile()) {
                 zip.SaveProgress += SaveProgress;
                 zip.AddDirectory(directory);
                 zip.Save(targetZip);
               }
             }
            
             </code>
            
             <code lang="VB">
             Public Sub ZipUp(ByVal targetZip As String, ByVal directory As String)
                 Using zip As ZipFile = New ZipFile
                     AddHandler zip.SaveProgress, AddressOf MySaveProgress
                     zip.AddDirectory(directory)
                     zip.Save(targetZip)
                 End Using
             End Sub
            
             Private Shared justHadByteUpdate As Boolean = False
            
             Public Shared Sub MySaveProgress(ByVal sender As Object, ByVal e As SaveProgressEventArgs)
                 If (e.EventType Is ZipProgressEventType.Saving_Started) Then
                     Console.WriteLine("Saving: {0}", e.ArchiveName)
            
                 ElseIf (e.EventType Is ZipProgressEventType.Saving_Completed) Then
                     justHadByteUpdate = False
                     Console.WriteLine
                     Console.WriteLine("Done: {0}", e.ArchiveName)
            
                 ElseIf (e.EventType Is ZipProgressEventType.Saving_BeforeWriteEntry) Then
                     If justHadByteUpdate Then
                         Console.WriteLine
                     End If
                     Console.WriteLine("  Writing: {0} ({1}/{2})", e.CurrentEntry.FileName, e.EntriesSaved, e.EntriesTotal)
                     justHadByteUpdate = False
            
                 ElseIf (e.EventType Is ZipProgressEventType.Saving_EntryBytesRead) Then
                     If justHadByteUpdate Then
                         Console.SetCursorPosition(0, Console.CursorTop)
                     End If
                     Console.Write("     {0}/{1} ({2:N0}%)", e.BytesTransferred, _
                                   e.TotalBytesToTransfer, _
                                   (CDbl(e.BytesTransferred) / (0.01 * e.TotalBytesToTransfer)))
                     justHadByteUpdate = True
                 End If
             End Sub
             </code>
             </example>
            
             <example>
            
             This is a more complete example of using the SaveProgress
             events in a Windows Forms application, with a
             Thread object.
            
             <code lang="C#">
             delegate void SaveEntryProgress(SaveProgressEventArgs e);
             delegate void ButtonClick(object sender, EventArgs e);
            
             public class WorkerOptions
             {
                 public string ZipName;
                 public string Folder;
                 public string Encoding;
                 public string Comment;
                 public int ZipFlavor;
                 public Zip64Option Zip64;
             }
            
             private int _progress2MaxFactor;
             private bool _saveCanceled;
             private long _totalBytesBeforeCompress;
             private long _totalBytesAfterCompress;
             private Thread _workerThread;
            
            
             private void btnZipup_Click(object sender, EventArgs e)
             {
                 KickoffZipup();
             }
            
             private void btnCancel_Click(object sender, EventArgs e)
             {
                 if (this.lblStatus.InvokeRequired)
                 {
                     this.lblStatus.Invoke(new ButtonClick(this.btnCancel_Click), new object[] { sender, e });
                 }
                 else
                 {
                     _saveCanceled = true;
                     lblStatus.Text = "Canceled...";
                     ResetState();
                 }
             }
            
             private void KickoffZipup()
             {
                 _folderName = tbDirName.Text;
            
                 if (_folderName == null || _folderName == "") return;
                 if (this.tbZipName.Text == null || this.tbZipName.Text == "") return;
            
                 // check for existence of the zip file:
                 if (System.IO.File.Exists(this.tbZipName.Text))
                 {
                     var dlgResult = MessageBox.Show(String.Format("The file you have specified ({0}) already exists." +
                                                                   "  Do you want to overwrite this file?", this.tbZipName.Text),
                                                     "Confirmation is Required", MessageBoxButtons.YesNo, MessageBoxIcon.Question);
                     if (dlgResult != DialogResult.Yes) return;
                     System.IO.File.Delete(this.tbZipName.Text);
                 }
            
                  _saveCanceled = false;
                 _nFilesCompleted = 0;
                 _totalBytesAfterCompress = 0;
                 _totalBytesBeforeCompress = 0;
                 this.btnOk.Enabled = false;
                 this.btnOk.Text = "Zipping...";
                 this.btnCancel.Enabled = true;
                 lblStatus.Text = "Zipping...";
            
                 var options = new WorkerOptions
                 {
                     ZipName = this.tbZipName.Text,
                     Folder = _folderName,
                     Encoding = "ibm437"
                 };
            
                 if (this.comboBox1.SelectedIndex != 0)
                 {
                     options.Encoding = this.comboBox1.SelectedItem.ToString();
                 }
            
                 if (this.radioFlavorSfxCmd.Checked)
                     options.ZipFlavor = 2;
                 else if (this.radioFlavorSfxGui.Checked)
                     options.ZipFlavor = 1;
                 else options.ZipFlavor = 0;
            
                 if (this.radioZip64AsNecessary.Checked)
                     options.Zip64 = Zip64Option.AsNecessary;
                 else if (this.radioZip64Always.Checked)
                     options.Zip64 = Zip64Option.Always;
                 else options.Zip64 = Zip64Option.Never;
            
                 options.Comment = String.Format("Encoding:{0} || Flavor:{1} || ZIP64:{2}\r\nCreated at {3} || {4}\r\n",
                             options.Encoding,
                             FlavorToString(options.ZipFlavor),
                             options.Zip64.ToString(),
                             System.DateTime.Now.ToString("yyyy-MMM-dd HH:mm:ss"),
                             this.Text);
            
                 if (this.tbComment.Text != TB_COMMENT_NOTE)
                     options.Comment += this.tbComment.Text;
            
                 _workerThread = new Thread(this.DoSave);
                 _workerThread.Name = "Zip Saver thread";
                 _workerThread.Start(options);
                 this.Cursor = Cursors.WaitCursor;
              }
            
            
             private void DoSave(Object p)
             {
                 WorkerOptions options = p as WorkerOptions;
                 try
                 {
                     using (var zip1 = new ZipFile())
                     {
                         zip1.ProvisionalAlternateEncoding = System.Text.Encoding.GetEncoding(options.Encoding);
                         zip1.Comment = options.Comment;
                         zip1.AddDirectory(options.Folder);
                         _entriesToZip = zip1.EntryFileNames.Count;
                         SetProgressBars();
                         zip1.SaveProgress += this.zip1_SaveProgress;
            
                         zip1.UseZip64WhenSaving = options.Zip64;
            
                         if (options.ZipFlavor == 1)
                             zip1.SaveSelfExtractor(options.ZipName, SelfExtractorFlavor.WinFormsApplication);
                         else if (options.ZipFlavor == 2)
                             zip1.SaveSelfExtractor(options.ZipName, SelfExtractorFlavor.ConsoleApplication);
                         else
                             zip1.Save(options.ZipName);
                     }
                 }
                 catch (System.Exception exc1)
                 {
                     MessageBox.Show(String.Format("Exception while zipping: {0}", exc1.Message));
                     btnCancel_Click(null, null);
                 }
             }
            
            
            
             void zip1_SaveProgress(object sender, SaveProgressEventArgs e)
             {
                 switch (e.EventType)
                 {
                     case ZipProgressEventType.Saving_AfterWriteEntry:
                         StepArchiveProgress(e);
                         break;
                     case ZipProgressEventType.Saving_EntryBytesRead:
                         StepEntryProgress(e);
                         break;
                     case ZipProgressEventType.Saving_Completed:
                         SaveCompleted();
                         break;
                     case ZipProgressEventType.Saving_AfterSaveTempArchive:
                         // this event only occurs when saving an SFX file
                         TempArchiveSaved();
                         break;
                 }
                 if (_saveCanceled)
                     e.Cancel = true;
             }
            
            
            
             private void StepArchiveProgress(SaveProgressEventArgs e)
             {
                 if (this.progressBar1.InvokeRequired)
                 {
                     this.progressBar1.Invoke(new SaveEntryProgress(this.StepArchiveProgress), new object[] { e });
                 }
                 else
                 {
                     if (!_saveCanceled)
                     {
                         _nFilesCompleted++;
                         this.progressBar1.PerformStep();
                         _totalBytesAfterCompress += e.CurrentEntry.CompressedSize;
                         _totalBytesBeforeCompress += e.CurrentEntry.UncompressedSize;
            
                         // reset the progress bar for the entry:
                         this.progressBar2.Value = this.progressBar2.Maximum = 1;
            
                         this.Update();
                     }
                 }
             }
            
            
             private void StepEntryProgress(SaveProgressEventArgs e)
             {
                 if (this.progressBar2.InvokeRequired)
                 {
                     this.progressBar2.Invoke(new SaveEntryProgress(this.StepEntryProgress), new object[] { e });
                 }
                 else
                 {
                     if (!_saveCanceled)
                     {
                         if (this.progressBar2.Maximum == 1)
                         {
                             // reset
                             Int64 max = e.TotalBytesToTransfer;
                             _progress2MaxFactor = 0;
                             while (max &gt; System.Int32.MaxValue)
                             {
                                 max /= 2;
                                 _progress2MaxFactor++;
                             }
                             this.progressBar2.Maximum = (int)max;
                             lblStatus.Text = String.Format("{0} of {1} files...({2})",
                                 _nFilesCompleted + 1, _entriesToZip, e.CurrentEntry.FileName);
                         }
            
                          int xferred = e.BytesTransferred &gt;&gt; _progress2MaxFactor;
            
                          this.progressBar2.Value = (xferred &gt;= this.progressBar2.Maximum)
                             ? this.progressBar2.Maximum
                             : xferred;
            
                          this.Update();
                     }
                 }
             }
            
             private void SaveCompleted()
             {
                 if (this.lblStatus.InvokeRequired)
                 {
                     this.lblStatus.Invoke(new MethodInvoker(this.SaveCompleted));
                 }
                 else
                 {
                     lblStatus.Text = String.Format("Done, Compressed {0} files, {1:N0}% of original.",
                         _nFilesCompleted, (100.00 * _totalBytesAfterCompress) / _totalBytesBeforeCompress);
                      ResetState();
                 }
             }
            
             private void ResetState()
             {
                 this.btnCancel.Enabled = false;
                 this.btnOk.Enabled = true;
                 this.btnOk.Text = "Zip it!";
                 this.progressBar1.Value = 0;
                 this.progressBar2.Value = 0;
                 this.Cursor = Cursors.Default;
                 if (!_workerThread.IsAlive)
                     _workerThread.Join();
             }
             </code>
            
             </example>
            
             <seealso cref="E:Ionic.Zip.ZipFile.ReadProgress"/>
             <seealso cref="E:Ionic.Zip.ZipFile.AddProgress"/>
             <seealso cref="E:Ionic.Zip.ZipFile.ExtractProgress"/>
        </member>
        <member name="E:Ionic.Zip.ZipFile.ReadProgress">
             <summary>
             An event handler invoked before, during, and after the reading of a zip archive.
             </summary>
            
             <remarks>
             <para>
             Depending on the particular event being signaled, different properties on the
             <see cref="T:Ionic.Zip.ReadProgressEventArgs"/> parameter are set.  The following table
             summarizes the available EventTypes and the conditions under which this
             event handler is invoked with a <c>ReadProgressEventArgs</c> with the given EventType.
             </para>
            
             <list type="table">
             <listheader>
             <term>value of EntryType</term>
             <description>Meaning and conditions</description>
             </listheader>
            
             <item>
             <term>ZipProgressEventType.Reading_Started</term>
             <description>Fired just as ZipFile.Read() begins. Meaningful properties: ArchiveName.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Reading_Completed</term>
             <description>Fired when ZipFile.Read() has completed. Meaningful properties: ArchiveName.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Reading_ArchiveBytesRead</term>
             <description>Fired while reading, updates the number of bytes read for the entire archive.
             Meaningful properties: ArchiveName, CurrentEntry, BytesTransferred, TotalBytesToTransfer.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Reading_BeforeReadEntry</term>
             <description>Indicates an entry is about to be read from the archive.
             Meaningful properties: ArchiveName, EntriesTotal.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Reading_AfterReadEntry</term>
             <description>Indicates an entry has just been read from the archive.
             Meaningful properties: ArchiveName, EntriesTotal, CurrentEntry.
             </description>
             </item>
            
             </list>
             </remarks>
            
             <seealso cref="E:Ionic.Zip.ZipFile.SaveProgress"/>
             <seealso cref="E:Ionic.Zip.ZipFile.AddProgress"/>
             <seealso cref="E:Ionic.Zip.ZipFile.ExtractProgress"/>
        </member>
        <member name="E:Ionic.Zip.ZipFile.ExtractProgress">
             <summary>
               An event handler invoked before, during, and after extraction of
               entries in the zip archive.
             </summary>
            
             <remarks>
             <para>
               Depending on the particular event, different properties on the <see cref="T:Ionic.Zip.ExtractProgressEventArgs"/> parameter are set.  The following
               table summarizes the available EventTypes and the conditions under
               which this event handler is invoked with a
               <c>ExtractProgressEventArgs</c> with the given EventType.
             </para>
            
             <list type="table">
             <listheader>
             <term>value of EntryType</term>
             <description>Meaning and conditions</description>
             </listheader>
            
             <item>
             <term>ZipProgressEventType.Extracting_BeforeExtractAll</term>
             <description>
               Set when ExtractAll() begins. The ArchiveName, Overwrite, and
               ExtractLocation properties are meaningful.</description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Extracting_AfterExtractAll</term>
             <description>
               Set when ExtractAll() has completed.  The ArchiveName, Overwrite,
               and ExtractLocation properties are meaningful.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Extracting_BeforeExtractEntry</term>
             <description>
               Set when an Extract() on an entry in the ZipFile has begun.
               Properties that are meaningful: ArchiveName, EntriesTotal,
               CurrentEntry, Overwrite, ExtractLocation, EntriesExtracted.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Extracting_AfterExtractEntry</term>
             <description>
               Set when an Extract() on an entry in the ZipFile has completed.
               Properties that are meaningful: ArchiveName, EntriesTotal,
               CurrentEntry, Overwrite, ExtractLocation, EntriesExtracted.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Extracting_EntryBytesWritten</term>
             <description>
               Set within a call to Extract() on an entry in the ZipFile, as data
               is extracted for the entry.  Properties that are meaningful:
               ArchiveName, CurrentEntry, BytesTransferred, TotalBytesToTransfer.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Extracting_ExtractEntryWouldOverwrite</term>
             <description>
               Set within a call to Extract() on an entry in the ZipFile, when the
               extraction would overwrite an existing file. This event type is used
               only when <c>ExtractExistingFileAction</c> on the <c>ZipFile</c> or
               <c>ZipEntry</c> is set to <c>InvokeExtractProgressEvent</c>.
             </description>
             </item>
            
             </list>
            
             </remarks>
            
             <example>
             <code>
             private static bool justHadByteUpdate = false;
             public static void ExtractProgress(object sender, ExtractProgressEventArgs e)
             {
               if(e.EventType == ZipProgressEventType.Extracting_EntryBytesWritten)
               {
                 if (justHadByteUpdate)
                   Console.SetCursorPosition(0, Console.CursorTop);
            
                 Console.Write("   {0}/{1} ({2:N0}%)", e.BytesTransferred, e.TotalBytesToTransfer,
                               e.BytesTransferred / (0.01 * e.TotalBytesToTransfer ));
                 justHadByteUpdate = true;
               }
               else if(e.EventType == ZipProgressEventType.Extracting_BeforeExtractEntry)
               {
                 if (justHadByteUpdate)
                   Console.WriteLine();
                 Console.WriteLine("Extracting: {0}", e.CurrentEntry.FileName);
                 justHadByteUpdate= false;
               }
             }
            
             public static ExtractZip(string zipToExtract, string directory)
             {
               string TargetDirectory= "extract";
               using (var zip = ZipFile.Read(zipToExtract)) {
                 zip.ExtractProgress += ExtractProgress;
                 foreach (var e in zip1)
                 {
                   e.Extract(TargetDirectory, true);
                 }
               }
             }
            
             </code>
             <code lang="VB">
             Public Shared Sub Main(ByVal args As String())
                 Dim ZipToUnpack As String = "C1P3SML.zip"
                 Dim TargetDir As String = "ExtractTest_Extract"
                 Console.WriteLine("Extracting file {0} to {1}", ZipToUnpack, TargetDir)
                 Using zip1 As ZipFile = ZipFile.Read(ZipToUnpack)
                     AddHandler zip1.ExtractProgress, AddressOf MyExtractProgress
                     Dim e As ZipEntry
                     For Each e In zip1
                         e.Extract(TargetDir, True)
                     Next
                 End Using
             End Sub
            
             Private Shared justHadByteUpdate As Boolean = False
            
             Public Shared Sub MyExtractProgress(ByVal sender As Object, ByVal e As ExtractProgressEventArgs)
                 If (e.EventType = ZipProgressEventType.Extracting_EntryBytesWritten) Then
                     If ExtractTest.justHadByteUpdate Then
                         Console.SetCursorPosition(0, Console.CursorTop)
                     End If
                     Console.Write("   {0}/{1} ({2:N0}%)", e.BytesTransferred, e.TotalBytesToTransfer, (CDbl(e.BytesTransferred) / (0.01 * e.TotalBytesToTransfer)))
                     ExtractTest.justHadByteUpdate = True
                 ElseIf (e.EventType = ZipProgressEventType.Extracting_BeforeExtractEntry) Then
                     If ExtractTest.justHadByteUpdate Then
                         Console.WriteLine
                     End If
                     Console.WriteLine("Extracting: {0}", e.CurrentEntry.FileName)
                     ExtractTest.justHadByteUpdate = False
                 End If
             End Sub
             </code>
             </example>
            
             <seealso cref="E:Ionic.Zip.ZipFile.SaveProgress"/>
             <seealso cref="E:Ionic.Zip.ZipFile.ReadProgress"/>
             <seealso cref="E:Ionic.Zip.ZipFile.AddProgress"/>
        </member>
        <member name="E:Ionic.Zip.ZipFile.AddProgress">
             <summary>
             An event handler invoked before, during, and after Adding entries to a zip archive.
             </summary>
            
             <remarks>
                 Adding a large number of entries to a zip file can take a long
                 time.  For example, when calling <see cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String)"/> on a
                 directory that contains 50,000 files, it could take 3 minutes or so.
                 This event handler allws an application to track the progress of the Add
                 operation, and to optionally cancel a lengthy Add operation.
             </remarks>
            
             <example>
             <code lang="C#">
            
             int _numEntriesToAdd= 0;
             int _numEntriesAdded= 0;
             void AddProgressHandler(object sender, AddProgressEventArgs e)
             {
                 switch (e.EventType)
                 {
                     case ZipProgressEventType.Adding_Started:
                         Console.WriteLine("Adding files to the zip...");
                         break;
                     case ZipProgressEventType.Adding_AfterAddEntry:
                         _numEntriesAdded++;
                         Console.WriteLine(String.Format("Adding file {0}/{1} :: {2}",
                                                  _numEntriesAdded, _numEntriesToAdd, e.CurrentEntry.FileName));
                         break;
                     case ZipProgressEventType.Adding_Completed:
                         Console.WriteLine("Added all files");
                         break;
                 }
             }
            
             void CreateTheZip()
             {
                 using (ZipFile zip = new ZipFile())
                 {
                     zip.AddProgress += AddProgressHandler;
                     zip.AddDirectory(System.IO.Path.GetFileName(DirToZip));
                     zip.Save(ZipFileToCreate);
                 }
             }
            
             </code>
            
             <code lang="VB">
            
             Private Sub AddProgressHandler(ByVal sender As Object, ByVal e As AddProgressEventArgs)
                 Select Case e.EventType
                     Case ZipProgressEventType.Adding_Started
                         Console.WriteLine("Adding files to the zip...")
                         Exit Select
                     Case ZipProgressEventType.Adding_AfterAddEntry
                         Console.WriteLine(String.Format("Adding file {0}", e.CurrentEntry.FileName))
                         Exit Select
                     Case ZipProgressEventType.Adding_Completed
                         Console.WriteLine("Added all files")
                         Exit Select
                 End Select
             End Sub
            
             Sub CreateTheZip()
                 Using zip as ZipFile = New ZipFile
                     AddHandler zip.AddProgress, AddressOf AddProgressHandler
                     zip.AddDirectory(System.IO.Path.GetFileName(DirToZip))
                     zip.Save(ZipFileToCreate);
                 End Using
             End Sub
            
             </code>
            
             </example>
            
             <seealso cref="E:Ionic.Zip.ZipFile.SaveProgress"/>
             <seealso cref="E:Ionic.Zip.ZipFile.ReadProgress"/>
             <seealso cref="E:Ionic.Zip.ZipFile.ExtractProgress"/>
        </member>
        <member name="E:Ionic.Zip.ZipFile.ZipError">
             <summary>
             An event that is raised when an error occurs during open or read of files
             while saving a zip archive.
             </summary>
            
             <remarks>
              <para>
                 Errors can occur as a file is being saved to the zip archive.  For
                 example, the File.Open may fail, or a File.Read may fail, because of
                 lock conflicts or other reasons.  If you add a handler to this event,
                 you can handle such errors in your own code.  If you don't add a
                 handler, the library will throw an exception if it encounters an I/O
                 error during a call to <c>Save()</c>.
              </para>
            
              <para>
                Setting a handler implicitly sets <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/> to
                <c>ZipErrorAction.InvokeErrorEvent</c>.
              </para>
            
              <para>
                The handler you add applies to all <see cref="T:Ionic.Zip.ZipEntry"/> items that are
                subsequently added to the <c>ZipFile</c> instance. If you set this
                property after you have added items to the <c>ZipFile</c>, but before you
                have called <c>Save()</c>, errors that occur while saving those items
                will not cause the error handler to be invoked.
              </para>
            
              <para>
                If you want to handle any errors that occur with any entry in the zip
                file using the same error handler, then add your error handler once,
                before adding any entries to the zip archive.
              </para>
            
              <para>
                In the error handler method, you need to set the <see cref="P:Ionic.Zip.ZipEntry.ZipErrorAction"/> property on the
                <c>ZipErrorEventArgs.CurrentEntry</c>.  This communicates back to
                DotNetZip what you would like to do with this particular error.  Within
                an error handler, if you set the <c>ZipEntry.ZipErrorAction</c> property
                on the <c>ZipEntry</c> to <c>ZipErrorAction.InvokeErrorEvent</c> or if
                you don't set it at all, the library will throw the exception. (It is the
                same as if you had set the <c>ZipEntry.ZipErrorAction</c> property on the
                <c>ZipEntry</c> to <c>ZipErrorAction.Throw</c>.) If you set the
                <c>ZipErrorEventArgs.Cancel</c> to true, the entire <c>Save()</c> will be
                canceled.
              </para>
            
              <para>
                In the case that you use <c>ZipErrorAction.Skip</c>, implying that
                you want to skip the entry for which there's been an error, DotNetZip
                tries to seek backwards in the output stream, and truncate all bytes
                written on behalf of that particular entry. This works only if the
                output stream is seekable.  It will not work, for example, when using
                ASPNET's Response.OutputStream.
              </para>
            
             </remarks>
            
             <example>
            
             This example shows how to use an event handler to handle
             errors during save of the zip file.
             <code lang="C#">
            
             public static void MyZipError(object sender, ZipErrorEventArgs e)
             {
                 Console.WriteLine("Error saving {0}...", e.FileName);
                 Console.WriteLine("   Exception: {0}", e.exception);
                 ZipEntry entry = e.CurrentEntry;
                 string response = null;
                 // Ask the user whether he wants to skip this error or not
                 do
                 {
                     Console.Write("Retry, Skip, Throw, or Cancel ? (R/S/T/C) ");
                     response = Console.ReadLine();
                     Console.WriteLine();
            
                 } while (response != null &amp;&amp;
                          response[0]!='S' &amp;&amp; response[0]!='s' &amp;&amp;
                          response[0]!='R' &amp;&amp; response[0]!='r' &amp;&amp;
                          response[0]!='T' &amp;&amp; response[0]!='t' &amp;&amp;
                          response[0]!='C' &amp;&amp; response[0]!='c');
            
                 e.Cancel = (response[0]=='C' || response[0]=='c');
            
                 if (response[0]=='S' || response[0]=='s')
                     entry.ZipErrorAction = ZipErrorAction.Skip;
                 else if (response[0]=='R' || response[0]=='r')
                     entry.ZipErrorAction = ZipErrorAction.Retry;
                 else if (response[0]=='T' || response[0]=='t')
                     entry.ZipErrorAction = ZipErrorAction.Throw;
             }
            
             public void SaveTheFile()
             {
               string directoryToZip = "fodder";
               string directoryInArchive = "files";
               string zipFileToCreate = "Archive.zip";
               using (var zip = new ZipFile())
               {
                 // set the event handler before adding any entries
                 zip.ZipError += MyZipError;
                 zip.AddDirectory(directoryToZip, directoryInArchive);
                 zip.Save(zipFileToCreate);
               }
             }
             </code>
            
             <code lang="VB">
             Private Sub MyZipError(ByVal sender As Object, ByVal e As Ionic.Zip.ZipErrorEventArgs)
                 ' At this point, the application could prompt the user for an action to take.
                 ' But in this case, this application will simply automatically skip the file, in case of error.
                 Console.WriteLine("Zip Error,  entry {0}", e.CurrentEntry.FileName)
                 Console.WriteLine("   Exception: {0}", e.exception)
                 ' set the desired ZipErrorAction on the CurrentEntry to communicate that to DotNetZip
                 e.CurrentEntry.ZipErrorAction = Zip.ZipErrorAction.Skip
             End Sub
            
             Public Sub SaveTheFile()
                 Dim directoryToZip As String = "fodder"
                 Dim directoryInArchive As String = "files"
                 Dim zipFileToCreate as String = "Archive.zip"
                 Using zipArchive As ZipFile = New ZipFile
                     ' set the event handler before adding any entries
                     AddHandler zipArchive.ZipError, AddressOf MyZipError
                     zipArchive.AddDirectory(directoryToZip, directoryInArchive)
                     zipArchive.Save(zipFileToCreate)
                 End Using
             End Sub
            
             </code>
             </example>
            
             <seealso cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>
        </member>
        <member name="T:Ionic.Zip.Zip64Option">
             <summary>
               Options for using ZIP64 extensions when saving zip archives.
             </summary>
            
             <remarks>
            
             <para>
               Designed many years ago, the <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">original zip
               specification from PKWARE</see> allowed for 32-bit quantities for the
               compressed and uncompressed sizes of zip entries, as well as a 32-bit quantity
               for specifying the length of the zip archive itself, and a maximum of 65535
               entries.  These limits are now regularly exceeded in many backup and archival
               scenarios.  Recently, PKWare added extensions to the original zip spec, called
               "ZIP64 extensions", to raise those limitations.  This property governs whether
               DotNetZip will use those extensions when writing zip archives. The use of
               these extensions is optional and explicit in DotNetZip because, despite the
               status of ZIP64 as a bona fide standard, many other zip tools and libraries do
               not support ZIP64, and therefore a zip file with ZIP64 extensions may be
               unreadable by some of those other tools.
             </para>
            
             <para>
               Set this property to <see cref="F:Ionic.Zip.Zip64Option.Always"/> to always use ZIP64
               extensions when saving, regardless of whether your zip archive needs it.
               Suppose you add 5 files, each under 100k, to a ZipFile. If you specify Always
               for this flag, you will get a ZIP64 archive, though the archive does not need
               to use ZIP64 because none of the original zip limits had been exceeded.
             </para>
            
             <para>
               Set this property to <see cref="F:Ionic.Zip.Zip64Option.Never"/> to tell the DotNetZip
               library to never use ZIP64 extensions.  This is useful for maximum
               compatibility and interoperability, at the expense of the capability of
               handling large files or large archives.  NB: Windows Explorer in Windows XP
               and Windows Vista cannot currently extract files from a zip64 archive, so if
               you want to guarantee that a zip archive produced by this library will work in
               Windows Explorer, use <c>Never</c>. If you set this property to <see cref="F:Ionic.Zip.Zip64Option.Never"/>, and your application creates a zip that would
               exceed one of the Zip limits, the library will throw an exception while saving
               the zip file.
             </para>
            
             <para>
               Set this property to <see cref="F:Ionic.Zip.Zip64Option.AsNecessary"/> to tell the
               DotNetZip library to use the ZIP64 extensions when required by the
               entry. After the file is compressed, the original and compressed sizes are
               checked, and if they exceed the limits described above, then zip64 can be
               used. That is the general idea, but there is an additional wrinkle when saving
               to a non-seekable device, like the ASP.NET <c>Response.OutputStream</c>, or
               <c>Console.Out</c>.  When using non-seekable streams for output, the entry
               header - which indicates whether zip64 is in use - is emitted before it is
               known if zip64 is necessary.  It is only after all entries have been saved
               that it can be known if ZIP64 will be required.  On seekable output streams,
               after saving all entries, the library can seek backward and re-emit the zip
               file header to be consistent with the actual ZIP64 requirement.  But using a
               non-seekable output stream, the library cannot seek backward, so the header
               can never be changed. In other words, the archive's use of ZIP64 extensions is
               not alterable after the header is emitted.  Therefore, when saving to
               non-seekable streams, using <see cref="F:Ionic.Zip.Zip64Option.AsNecessary"/> is the same
               as using <see cref="F:Ionic.Zip.Zip64Option.Always"/>: it will always produce a zip
               archive that uses ZIP64 extensions.
             </para>
            
             </remarks>
        </member>
        <member name="F:Ionic.Zip.Zip64Option.Default">
            <summary>
            The default behavior, which is "Never".
            (For COM clients, this is a 0 (zero).)
            </summary>
        </member>
        <member name="F:Ionic.Zip.Zip64Option.Never">
            <summary>
            Do not use ZIP64 extensions when writing zip archives.
            (For COM clients, this is a 0 (zero).)
            </summary>
        </member>
        <member name="F:Ionic.Zip.Zip64Option.AsNecessary">
            <summary>
            Use ZIP64 extensions when writing zip archives, as necessary.
            For example, when a single entry exceeds 0xFFFFFFFF in size, or when the archive as a whole
            exceeds 0xFFFFFFFF in size, or when there are more than 65535 entries in an archive.
            (For COM clients, this is a 1.)
            </summary>
        </member>
        <member name="F:Ionic.Zip.Zip64Option.Always">
            <summary>
            Always use ZIP64 extensions when writing zip archives, even when unnecessary.
            (For COM clients, this is a 2.)
            </summary>
        </member>
        <member name="T:Ionic.Zip.ZipOption">
            <summary>
             An enum representing the values on a three-way toggle switch
             for various options in the library. This might be used to
             specify whether to employ a particular text encoding, or to use
             ZIP64 extensions, or some other option.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipOption.Default">
            <summary>
            The default behavior. This is the same as "Never".
            (For COM clients, this is a 0 (zero).)
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipOption.Never">
            <summary>
            Never use the associated option.
            (For COM clients, this is a 0 (zero).)
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipOption.AsNecessary">
            <summary>
            Use the associated behavior "as necessary."
            (For COM clients, this is a 1.)
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipOption.Always">
            <summary>
            Use the associated behavior Always, whether necessary or not.
            (For COM clients, this is a 2.)
            </summary>
        </member>
        <member name="T:Ionic.Zip.ReadOptions">
             <summary>
               A class for collecting the various options that can be used when
               Reading zip files for extraction or update.
             </summary>
            
             <remarks>
               <para>
                 When reading a zip file, there are several options an
                 application can set, to modify how the file is read, or what
                 the library does while reading.  This class collects those
                 options into one container.
               </para>
            
               <para>
                 Pass an instance of the <c>ReadOptions</c> class into the
                 <c>ZipFile.Read()</c> method.
               </para>
            
             <seealso cref="M:Ionic.Zip.ZipFile.Read(System.String,Ionic.Zip.ReadOptions)"/>.
             <seealso cref="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,Ionic.Zip.ReadOptions)"/>.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ReadOptions.ReadProgress">
            <summary>
            An event handler for Read operations.  When opening large zip
            archives, you may want to display a progress bar or other
            indicator of status progress while reading.  This parameter
            allows you to specify a ReadProgress Event Handler directly.
            When you call <c>Read()</c>, the progress event is invoked as
            necessary.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ReadOptions.StatusMessageWriter">
            <summary>
            The <c>System.IO.TextWriter</c> to use for writing verbose status messages
            during operations on the zip archive.  A console application may wish to
            pass <c>System.Console.Out</c> to get messages on the Console. A graphical
            or headless application may wish to capture the messages in a different
            <c>TextWriter</c>, such as a <c>System.IO.StringWriter</c>.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ReadOptions.Encoding">
             <summary>
             The <c>System.Text.Encoding</c> to use when reading in the zip archive. Be
             careful specifying the encoding.  If the value you use here is not the same
             as the Encoding used when the zip archive was created (possibly by a
             different archiver) you will get unexpected results and possibly exceptions.
             </summary>
            
             <seealso cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>
            
        </member>
        <member name="T:Ionic.Zip.SelfExtractorFlavor">
            <summary>
            An enum that provides the different self-extractor flavors
            </summary>
        </member>
        <member name="F:Ionic.Zip.SelfExtractorFlavor.ConsoleApplication">
            <summary>
            A self-extracting zip archive that runs from the console or
            command line.
            </summary>
        </member>
        <member name="F:Ionic.Zip.SelfExtractorFlavor.WinFormsApplication">
            <summary>
            A self-extracting zip archive that presents a graphical user
            interface when it is executed.
            </summary>
        </member>
        <member name="T:Ionic.Zip.SelfExtractorSaveOptions">
            <summary>
            The options for generating a self-extracting archive.
            </summary>
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.Flavor">
            <summary>
              The type of SFX to create.
            </summary>
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.PostExtractCommandLine">
             <summary>
               The command to run after extraction.
             </summary>
            
             <remarks>
             <para>
               This is optional. Leave it empty (<c>null</c> in C# or <c>Nothing</c> in
               VB) to run no command after extraction.
             </para>
            
             <para>
               If it is non-empty, the SFX will execute the command specified in this
               string on the user's machine, and using the extract directory as the
               working directory for the process, after unpacking the archive. The
               program to execute can include a path, if you like. If you want to execute
               a program that accepts arguments, specify the program name, followed by a
               space, and then the arguments for the program, each separated by a space,
               just as you would on a normal command line. Example: <c>program.exe arg1
               arg2</c>.  The string prior to the first space will be taken as the
               program name, and the string following the first space specifies the
               arguments to the program.
             </para>
            
             <para>
               If you want to execute a program that has a space in the name or path of
               the file, surround the program name in double-quotes. The first character
               of the command line should be a double-quote character, and there must be
               a matching double-quote following the end of the program file name. Any
               optional arguments to the program follow that, separated by
               spaces. Example: <c>"c:\project files\program name.exe" arg1 arg2</c>.
             </para>
            
             <para>
               If the flavor of the SFX is <c>SelfExtractorFlavor.ConsoleApplication</c>,
               then the SFX starts a new process, using this string as the post-extract
               command line.  The SFX waits for the process to exit.  The exit code of
               the post-extract command line is returned as the exit code of the
               command-line self-extractor exe. A non-zero exit code is typically used to
               indicated a failure by the program. In the case of an SFX, a non-zero exit
               code may indicate a failure during extraction, OR, it may indicate a
               failure of the run-after-extract program if specified, OR, it may indicate
               the run-after-extract program could not be fuond. There is no way to
               distinguish these conditions from the calling shell, aside from parsing
               the output of the SFX. If you have Quiet set to <c>true</c>, you may not
               see error messages, if a problem occurs.
             </para>
            
             <para>
               If the flavor of the SFX is
               <c>SelfExtractorFlavor.WinFormsApplication</c>, then the SFX starts a new
               process, using this string as the post-extract command line, and using the
               extract directory as the working directory for the process. The SFX does
               not wait for the command to complete, and does not check the exit code of
               the program. If the run-after-extract program cannot be fuond, a message
               box is displayed indicating that fact.
             </para>
            
             <para>
               You can specify environment variables within this string, with a format like
               <c>%NAME%</c>. The value of these variables will be expanded at the time
               the SFX is run. Example: <c>%WINDIR%\system32\xcopy.exe</c> may expand at
               runtime to <c>c:\Windows\System32\xcopy.exe</c>.
             </para>
            
             <para>
               By combining this with the <c>RemoveUnpackedFilesAfterExecute</c>
               flag, you can create an SFX that extracts itself, runs a file that
               was extracted, then deletes all the files that were extracted. If
               you want it to run "invisibly" then set <c>Flavor</c> to
               <c>SelfExtractorFlavor.ConsoleApplication</c>, and set <c>Quiet</c>
               to true.  The user running such an EXE will see a console window
               appear, then disappear quickly.  You may also want to specify the
               default extract location, with <c>DefaultExtractDirectory</c>.
             </para>
            
             <para>
               If you set <c>Flavor</c> to
               <c>SelfExtractorFlavor.WinFormsApplication</c>, and set <c>Quiet</c> to
               true, then a GUI with progressbars is displayed, but it is
               "non-interactive" - it accepts no input from the user.  Instead the SFX
               just automatically unpacks and exits.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.DefaultExtractDirectory">
             <summary>
               The default extract directory the user will see when
               running the self-extracting archive.
             </summary>
            
             <remarks>
             <para>
               Passing null (or Nothing in VB) here will cause the Self Extractor to use
               the the user's personal directory (<see cref="F:System.Environment.SpecialFolder.Personal"/>) for the default extract
               location.
             </para>
            
             <para>
               This is only a default location.  The actual extract location will be
               settable on the command line when the SFX is executed.
             </para>
            
             <para>
               You can specify environment variables within this string,
               with <c>%NAME%</c>. The value of these variables will be
               expanded at the time the SFX is run. Example:
               <c>%USERPROFILE%\Documents\unpack</c> may expand at runtime to
               <c>c:\users\melvin\Documents\unpack</c>.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.IconFile">
             <summary>
               The name of an .ico file in the filesystem to use for the application icon
               for the generated SFX.
             </summary>
            
             <remarks>
             <para>
               Normally, DotNetZip will embed an "zipped folder" icon into the generated
               SFX.  If you prefer to use a different icon, you can specify it here. It
               should be a .ico file.  This file is passed as the <c>/win32icon</c>
               option to the csc.exe compiler when constructing the SFX file.
             </para>
             </remarks>
            
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.Quiet">
             <summary>
               Whether the ConsoleApplication SFX will be quiet during extraction.
             </summary>
            
             <remarks>
             <para>
               This option affects the way the generated SFX runs. By default it is
               false.  When you set it to true,...
             </para>
            
             <list type="table">
               <listheader>
                 <term>Flavor</term>
                 <description>Behavior</description>
               </listheader>
            
             <item>
               <term><c>ConsoleApplication</c></term>
               <description><para>no messages will be emitted during successful
                 operation.</para> <para> Double-clicking the SFX in Windows
                 Explorer or as an attachment in an email will cause a console
                 window to appear briefly, before it disappears. If you run the
                 ConsoleApplication SFX from the cmd.exe prompt, it runs as a
                 normal console app; by default, because it is quiet, it displays
                 no messages to the console.  If you pass the -v+ command line
                 argument to the Console SFX when you run it, you will get verbose
                 messages to the console. </para>
               </description>
             </item>
            
             <item>
               <term><c>WinFormsApplication</c></term>
               <description>the SFX extracts automatically when the application
                    is launched, with no additional user input.
               </description>
             </item>
            
             </list>
            
             <para>
               When you set it to false,...
             </para>
            
             <list type="table">
               <listheader>
                 <term>Flavor</term>
                 <description>Behavior</description>
               </listheader>
            
             <item>
               <term><c>ConsoleApplication</c></term>
               <description><para>the extractor will emit a
                 message to the console for each entry extracted.</para>
                 <para>
                   When double-clicking to launch the SFX, the console window will
                   remain, and the SFX will emit a message for each file as it
                   extracts. The messages fly by quickly, they won't be easily
                   readable, unless the extracted files are fairly large.
                 </para>
               </description>
             </item>
            
             <item>
               <term><c>WinFormsApplication</c></term>
               <description>the SFX presents a forms UI and allows the user to select
                 options before extracting.
               </description>
             </item>
            
             </list>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.ExtractExistingFile">
            <summary>
              Specify what the self-extractor will do when extracting an entry
              would overwrite an existing file.
            </summary>
            <remarks>
            <para>
              The default behavvior is to Throw.
            </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.RemoveUnpackedFilesAfterExecute">
             <summary>
               Whether to remove the files that have been unpacked, after executing the
               PostExtractCommandLine.
             </summary>
            
             <remarks>
             <para>
               If true, and if there is a <see cref="P:Ionic.Zip.SelfExtractorSaveOptions.PostExtractCommandLine">
               PostExtractCommandLine</see>, and if the command runs successfully,
               then the files that the SFX unpacked will be removed, afterwards.  If
               the command does not complete successfully (non-zero return code),
               that is interpreted as a failure, and the extracted files will not be
               removed.
             </para>
            
             <para>
               Setting this flag, and setting <c>Flavor</c> to
               <c>SelfExtractorFlavor.ConsoleApplication</c>, and setting <c>Quiet</c> to
               true, results in an SFX that extracts itself, runs a file that was
               extracted, then deletes all the files that were extracted, with no
               intervention by the user.  You may also want to specify the default
               extract location, with <c>DefaultExtractDirectory</c>.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.FileVersion">
             <summary>
               The file version number to embed into the generated EXE. It will show up, for
               example, during a mouseover in Windows Explorer.
             </summary>
            
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.ProductVersion">
             <summary>
               The product version to embed into the generated EXE. It will show up, for
               example, during a mouseover in Windows Explorer.
             </summary>
            
             <remarks>
               You can use any arbitrary string, but a human-readable version number is
               recommended. For example "v1.2 alpha" or "v4.2 RC2".  If you specify nothing,
               then there is no product version embedded into the EXE.
             </remarks>
            
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.Copyright">
             <summary>
               The copyright notice, if any, to embed into the generated EXE.
             </summary>
            
             <remarks>
               It will show up, for example, while viewing properties of the file in
               Windows Explorer.  You can use any arbitrary string, but typically you
               want something like "Copyright © Dino Chiesa 2011".
             </remarks>
            
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.Description">
             <summary>
               The description to embed into the generated EXE.
             </summary>
            
             <remarks>
               Use any arbitrary string.  This text will be displayed during a
               mouseover in Windows Explorer.  If you specify nothing, then the string
               "DotNetZip SFX Archive" is embedded into the EXE as the description.
             </remarks>
            
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.ProductName">
             <summary>
               The product name to embed into the generated EXE.
             </summary>
            
             <remarks>
               Use any arbitrary string. This text will be displayed
               while viewing properties of the EXE file in
               Windows Explorer.
             </remarks>
            
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.SfxExeWindowTitle">
             <summary>
               The title to display in the Window of a GUI SFX, while it extracts.
             </summary>
            
             <remarks>
               <para>
                 By default the title show in the GUI window of a self-extractor
                 is "DotNetZip Self-extractor (http://DotNetZip.codeplex.com/)".
                 You can change that by setting this property before saving the SFX.
               </para>
            
               <para>
                 This property has an effect only when producing a Self-extractor
                 of flavor <c>SelfExtractorFlavor.WinFormsApplication</c>.
               </para>
             </remarks>
            
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.AdditionalCompilerSwitches">
            <summary>
              Additional options for the csc.exe compiler, when producing the SFX
              EXE.
            </summary>
            <exclude/>
        </member>
        <member name="M:Ionic.BZip2.BitWriter.Reset">
            <summary>
              Reset the BitWriter.
            </summary>
            <remarks>
              <para>
                This is useful when the BitWriter writes into a MemoryStream, and
                is used by a BZip2Compressor, which itself is re-used for multiple
                distinct data blocks.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.BitWriter.WriteBits(System.Int32,System.UInt32)">
            <summary>
              Write some number of bits from the given value, into the output.
            </summary>
            <remarks>
              <para>
                The nbits value should be a max of 25, for safety. For performance
                reasons, this method does not check!
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.BitWriter.WriteByte(System.Byte)">
            <summary>
              Write a full 8-bit byte into the output.
            </summary>
        </member>
        <member name="M:Ionic.BZip2.BitWriter.WriteInt(System.UInt32)">
            <summary>
              Write four 8-bit bytes into the output.
            </summary>
        </member>
        <member name="M:Ionic.BZip2.BitWriter.Flush">
            <summary>
              Write all available byte-aligned bytes.
            </summary>
            <remarks>
              <para>
                This method writes no new output, but flushes any accumulated
                bits. At completion, the accumulator may contain up to 7
                bits.
              </para>
              <para>
                This is necessary when re-assembling output from N independent
                compressors, one for each of N blocks. The output of any
                particular compressor will in general have some fragment of a byte
                remaining. This fragment needs to be accumulated into the
                parent BZip2OutputStream.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.BitWriter.FinishAndPad">
            <summary>
              Writes all available bytes, and emits padding for the final byte as
              necessary. This must be the last method invoked on an instance of
              BitWriter.
            </summary>
        </member>
        <member name="P:Ionic.BZip2.BitWriter.RemainingBits">
            <summary>
              Delivers the remaining bits, left-aligned, in a byte.
            </summary>
            <remarks>
              <para>
                This is valid only if NumRemainingBits is less than 8;
                in other words it is valid only after a call to Flush().
              </para>
            </remarks>
        </member>
        <member name="F:Ionic.BZip2.BZip2Compressor.increments">
            Knuth's increments seem to work better than Incerpi-Sedgewick here.
            Possibly because the number of elems to sort is usually small, typically
            &lt;= 20.
        </member>
        <member name="M:Ionic.BZip2.BZip2Compressor.#ctor(Ionic.BZip2.BitWriter)">
            <summary>
              BZip2Compressor writes its compressed data out via a BitWriter. This
              is necessary because BZip2 does byte shredding.
            </summary>
        </member>
        <member name="M:Ionic.BZip2.BZip2Compressor.Fill(System.Byte[],System.Int32,System.Int32)">
            <summary>
              Accept new bytes into the compressor data buffer
            </summary>
            <remarks>
              <para>
                This method does the first-level (cheap) run-length encoding, and
                stores the encoded data into the rle block.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.BZip2Compressor.write0(System.Byte)">
             <summary>
               Process one input byte into the block.
             </summary>
            
             <remarks>
               <para>
                 To "process" the byte means to do the run-length encoding.
                 There are 3 possible return values:
            
                    0 - the byte was not written, in other words, not
                        encoded into the block. This happens when the
                        byte b would require the start of a new run, and
                        the block has no more room for new runs.
            
                    1 - the byte was written, and the block is not full.
            
                    2 - the byte was written, and the block is full.
            
               </para>
             </remarks>
             <returns>0 if the byte was not written, non-zero if written.</returns>
        </member>
        <member name="M:Ionic.BZip2.BZip2Compressor.AddRunToOutputBlock(System.Boolean)">
             <summary>
               Append one run to the output block.
             </summary>
            
             <remarks>
               <para>
                 This compressor does run-length-encoding before BWT and etc. This
                 method simply appends a run to the output block. The append always
                 succeeds. The return value indicates whether the block is full:
                 false (not full) implies that at least one additional run could be
                 processed.
               </para>
             </remarks>
             <returns>true if the block is now full; otherwise false.</returns>
        </member>
        <member name="M:Ionic.BZip2.BZip2Compressor.CompressAndWrite">
            <summary>
              Compress the data that has been placed (Run-length-encoded) into the
              block. The compressed data goes into the CompressedBytes array.
            </summary>
            <remarks>
              <para>
                Side effects: 1.  fills the CompressedBytes array.  2. sets the
                AvailableBytesOut property.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.BZip2Compressor.mainSimpleSort(Ionic.BZip2.BZip2Compressor.CompressionState,System.Int32,System.Int32,System.Int32)">
             This is the most hammered method of this class.
            
             <p>
             This is the version using unrolled loops.
             </p>
        </member>
        <member name="M:Ionic.BZip2.BZip2Compressor.mainQSort3(Ionic.BZip2.BZip2Compressor.CompressionState,System.Int32,System.Int32,System.Int32)">
            Method "mainQSort3", file "blocksort.c", BZip2 1.0.2
        </member>
        <member name="P:Ionic.BZip2.BZip2Compressor.UncompressedBytes">
            <summary>
              The number of uncompressed bytes being held in the buffer.
            </summary>
            <remarks>
              <para>
                I am thinking this may be useful in a Stream that uses this
                compressor class. In the Close() method on the stream it could
                check this value to see if anything has been written at all.  You
                may think the stream could easily track the number of bytes it
                wrote, which would eliminate the need for this. But, there is the
                case where the stream writes a complete block, and it is full, and
                then writes no more. In that case the stream may want to check.
              </para>
            </remarks>
        </member>
        <member name="F:Ionic.BZip2.BZip2Compressor.CompressionState.quadrant">
            Array instance identical to sfmap, both are used only
            temporarily and independently, so we do not need to allocate
            additional memory.
        </member>
        <member name="T:Ionic.BZip2.BZip2InputStream">
            <summary>
              A read-only decorator stream that performs BZip2 decompression on Read.
            </summary>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.#ctor(System.IO.Stream)">
            <summary>
              Create a BZip2InputStream, wrapping it around the given input Stream.
            </summary>
            <remarks>
              <para>
                The input stream will be closed when the BZip2InputStream is closed.
              </para>
            </remarks>
            <param name='input'>The stream from which to read compressed data</param>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.#ctor(System.IO.Stream,System.Boolean)">
             <summary>
               Create a BZip2InputStream with the given stream, and
               specifying whether to leave the wrapped stream open when
               the BZip2InputStream is closed.
             </summary>
             <param name='input'>The stream from which to read compressed data</param>
             <param name='leaveOpen'>
               Whether to leave the input stream open, when the BZip2InputStream closes.
             </param>
            
             <example>
            
               This example reads a bzip2-compressed file, decompresses it,
               and writes the decompressed data into a newly created file.
            
               <code>
               var fname = "logfile.log.bz2";
               using (var fs = File.OpenRead(fname))
               {
                   using (var decompressor = new Ionic.BZip2.BZip2InputStream(fs))
                   {
                       var outFname = fname + ".decompressed";
                       using (var output = File.Create(outFname))
                       {
                           byte[] buffer = new byte[2048];
                           int n;
                           while ((n = decompressor.Read(buffer, 0, buffer.Length)) > 0)
                           {
                               output.Write(buffer, 0, n);
                           }
                       }
                   }
               }
               </code>
             </example>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Read data from the stream.
             </summary>
            
             <remarks>
               <para>
                 To decompress a BZip2 data stream, create a <c>BZip2InputStream</c>,
                 providing a stream that reads compressed data.  Then call Read() on
                 that <c>BZip2InputStream</c>, and the data read will be decompressed
                 as you read.
               </para>
            
               <para>
                 A <c>BZip2InputStream</c> can be used only for <c>Read()</c>, not for <c>Write()</c>.
               </para>
             </remarks>
            
             <param name="buffer">The buffer into which the read data should be placed.</param>
             <param name="offset">the offset within that data array to put the first byte read.</param>
             <param name="count">the number of bytes to read.</param>
             <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.ReadByte">
            <summary>
              Read a single byte from the stream.
            </summary>
            <returns>the byte read from the stream, or -1 if EOF</returns>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="offset">this is irrelevant, since it will always throw!</param>
            <param name="origin">this is irrelevant, since it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.SetLength(System.Int64)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="value">this is irrelevant, since it will always throw!</param>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
              Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="buffer">this parameter is never used</param>
            <param name="offset">this parameter is never used</param>
            <param name="count">this parameter is never used</param>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.Dispose(System.Boolean)">
            <summary>
              Dispose the stream.
            </summary>
            <param name="disposing">
              indicates whether the Dispose method was invoked by user code.
            </param>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.Close">
            <summary>
              Close the stream.
            </summary>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.GetBits(System.Int32)">
            <summary>
              Read n bits from input, right justifying the result.
            </summary>
            <remarks>
              <para>
                For example, if you read 1 bit, the result is either 0
                or 1.
              </para>
            </remarks>
            <param name ="n">
              The number of bits to read, always between 1 and 32.
            </param>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.hbCreateDecodeTables(System.Int32[],System.Int32[],System.Int32[],System.Char[],System.Int32,System.Int32,System.Int32)">
            Called by createHuffmanDecodingTables() exclusively.
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.createHuffmanDecodingTables(System.Int32,System.Int32)">
            Called by recvDecodingTables() exclusively.
        </member>
        <member name="P:Ionic.BZip2.BZip2InputStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:Ionic.BZip2.BZip2InputStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.BZip2.BZip2InputStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="P:Ionic.BZip2.BZip2InputStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="P:Ionic.BZip2.BZip2InputStream.Position">
             <summary>
             The position of the stream pointer.
             </summary>
            
             <remarks>
               Setting this property always throws a <see cref="T:System.NotImplementedException"/>. Reading will return the
               total number of uncompressed bytes read in.
             </remarks>
        </member>
        <member name="T:Ionic.BZip2.BZip2InputStream.CState">
            <summary>
              Compressor State
            </summary>
        </member>
        <member name="F:Ionic.BZip2.BZip2InputStream.DecompressionState.unzftab">
            Freq table collected to save a pass over the data during
            decompression.
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.DecompressionState.initTT(System.Int32)">
             Initializes the tt array.
            
             This method is called when the required length of the array is known.
             I don't initialize it at construction time to avoid unneccessary
             memory allocation when compressing small files.
        </member>
        <member name="T:Ionic.BZip2.BZip2OutputStream">
            <summary>
              A write-only decorator stream that compresses data as it is
              written using the BZip2 algorithm.
            </summary>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.#ctor(System.IO.Stream)">
             <summary>
               Constructs a new <c>BZip2OutputStream</c>, that sends its
               compressed output to the given output stream.
             </summary>
            
             <param name='output'>
               The destination stream, to which compressed output will be sent.
             </param>
            
             <example>
            
               This example reads a file, then compresses it with bzip2 file,
               and writes the compressed data into a newly created file.
            
               <code>
               var fname = "logfile.log";
               using (var fs = File.OpenRead(fname))
               {
                   var outFname = fname + ".bz2";
                   using (var output = File.Create(outFname))
                   {
                       using (var compressor = new Ionic.BZip2.BZip2OutputStream(output))
                       {
                           byte[] buffer = new byte[2048];
                           int n;
                           while ((n = fs.Read(buffer, 0, buffer.Length)) > 0)
                           {
                               compressor.Write(buffer, 0, n);
                           }
                       }
                   }
               }
               </code>
             </example>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.#ctor(System.IO.Stream,System.Int32)">
            <summary>
              Constructs a new <c>BZip2OutputStream</c> with specified blocksize.
            </summary>
            <param name = "output">the destination stream.</param>
            <param name = "blockSize">
              The blockSize in units of 100000 bytes.
              The valid range is 1..9.
            </param>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
              Constructs a new <c>BZip2OutputStream</c>.
            </summary>
              <param name = "output">the destination stream.</param>
            <param name = "leaveOpen">
              whether to leave the captive stream open upon closing this stream.
            </param>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.#ctor(System.IO.Stream,System.Int32,System.Boolean)">
             <summary>
               Constructs a new <c>BZip2OutputStream</c> with specified blocksize,
               and explicitly specifies whether to leave the wrapped stream open.
             </summary>
            
             <param name = "output">the destination stream.</param>
             <param name = "blockSize">
               The blockSize in units of 100000 bytes.
               The valid range is 1..9.
             </param>
             <param name = "leaveOpen">
               whether to leave the captive stream open upon closing this stream.
             </param>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.Close">
            <summary>
              Close the stream.
            </summary>
            <remarks>
              <para>
                This may or may not close the underlying stream.  Check the
                constructors that accept a bool value.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.Flush">
            <summary>
              Flush the stream.
            </summary>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write data to the stream.
             </summary>
             <remarks>
            
             <para>
               Use the <c>BZip2OutputStream</c> to compress data while writing:
               create a <c>BZip2OutputStream</c> with a writable output stream.
               Then call <c>Write()</c> on that <c>BZip2OutputStream</c>, providing
               uncompressed data as input.  The data sent to the output stream will
               be the compressed form of the input data.
             </para>
            
             <para>
               A <c>BZip2OutputStream</c> can be used only for <c>Write()</c> not for <c>Read()</c>.
             </para>
            
             </remarks>
            
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="offset">this is irrelevant, since it will always throw!</param>
            <param name="origin">this is irrelevant, since it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.SetLength(System.Int64)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="value">this is irrelevant, since it will always throw!</param>
        </member>
        <member name="M:Ionic.BZip2.BZip2OutputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
              Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="buffer">this parameter is never used</param>
            <param name="offset">this parameter is never used</param>
            <param name="count">this parameter is never used</param>
            <returns>never returns anything; always throws</returns>
        </member>
        <member name="P:Ionic.BZip2.BZip2OutputStream.BlockSize">
            <summary>
              The blocksize parameter specified at construction time.
            </summary>
        </member>
        <member name="P:Ionic.BZip2.BZip2OutputStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value is always false.
            </remarks>
        </member>
        <member name="P:Ionic.BZip2.BZip2OutputStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.BZip2.BZip2OutputStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value should always be true, unless and until the
            object is disposed and closed.
            </remarks>
        </member>
        <member name="P:Ionic.BZip2.BZip2OutputStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="P:Ionic.BZip2.BZip2OutputStream.Position">
             <summary>
             The position of the stream pointer.
             </summary>
            
             <remarks>
               Setting this property always throws a <see cref="T:System.NotImplementedException"/>. Reading will return the
               total number of uncompressed bytes written through.
             </remarks>
        </member>
        <member name="T:Ionic.BZip2.ParallelBZip2OutputStream">
             <summary>
               A write-only decorator stream that compresses data as it is
               written using the BZip2 algorithm. This stream compresses by
               block using multiple threads.
             </summary>
             <para>
               This class performs BZIP2 compression through writing.  For
               more information on the BZIP2 algorithm, see
               <see href="http://en.wikipedia.org/wiki/BZIP2"/>.
             </para>
            
             <para>
               This class is similar to <see cref="T:Ionic.BZip2.BZip2OutputStream"/>,
               except that this implementation uses an approach that employs multiple
               worker threads to perform the compression.  On a multi-cpu or multi-core
               computer, the performance of this class can be significantly higher than
               the single-threaded BZip2OutputStream, particularly for larger streams.
               How large?  Anything over 10mb is a good candidate for parallel
               compression.
             </para>
            
             <para>
               The tradeoff is that this class uses more memory and more CPU than the
               vanilla <c>BZip2OutputStream</c>. Also, for small files, the
               <c>ParallelBZip2OutputStream</c> can be much slower than the vanilla
               <c>BZip2OutputStream</c>, because of the overhead associated to using the
               thread pool.
             </para>
            
             <seealso cref="T:Ionic.BZip2.BZip2OutputStream"/>
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.#ctor(System.IO.Stream)">
             <summary>
               Constructs a new <c>ParallelBZip2OutputStream</c>, that sends its
               compressed output to the given output stream.
             </summary>
            
             <param name='output'>
               The destination stream, to which compressed output will be sent.
             </param>
            
             <example>
            
               This example reads a file, then compresses it with bzip2 file,
               and writes the compressed data into a newly created file.
            
               <code>
               var fname = "logfile.log";
               using (var fs = File.OpenRead(fname))
               {
                   var outFname = fname + ".bz2";
                   using (var output = File.Create(outFname))
                   {
                       using (var compressor = new Ionic.BZip2.ParallelBZip2OutputStream(output))
                       {
                           byte[] buffer = new byte[2048];
                           int n;
                           while ((n = fs.Read(buffer, 0, buffer.Length)) > 0)
                           {
                               compressor.Write(buffer, 0, n);
                           }
                       }
                   }
               }
               </code>
             </example>
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.#ctor(System.IO.Stream,System.Int32)">
            <summary>
              Constructs a new <c>ParallelBZip2OutputStream</c> with specified blocksize.
            </summary>
            <param name = "output">the destination stream.</param>
            <param name = "blockSize">
              The blockSize in units of 100000 bytes.
              The valid range is 1..9.
            </param>
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
              Constructs a new <c>ParallelBZip2OutputStream</c>.
            </summary>
              <param name = "output">the destination stream.</param>
            <param name = "leaveOpen">
              whether to leave the captive stream open upon closing this stream.
            </param>
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.#ctor(System.IO.Stream,System.Int32,System.Boolean)">
             <summary>
               Constructs a new <c>ParallelBZip2OutputStream</c> with specified blocksize,
               and explicitly specifies whether to leave the wrapped stream open.
             </summary>
            
             <param name = "output">the destination stream.</param>
             <param name = "blockSize">
               The blockSize in units of 100000 bytes.
               The valid range is 1..9.
             </param>
             <param name = "leaveOpen">
               whether to leave the captive stream open upon closing this stream.
             </param>
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.Close">
            <summary>
              Close the stream.
            </summary>
            <remarks>
              <para>
                This may or may not close the underlying stream.  Check the
                constructors that accept a bool value.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.Flush">
            <summary>
              Flush the stream.
            </summary>
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write data to the stream.
             </summary>
             <remarks>
            
             <para>
               Use the <c>ParallelBZip2OutputStream</c> to compress data while
               writing: create a <c>ParallelBZip2OutputStream</c> with a writable
               output stream.  Then call <c>Write()</c> on that
               <c>ParallelBZip2OutputStream</c>, providing uncompressed data as
               input.  The data sent to the output stream will be the compressed
               form of the input data.
             </para>
            
             <para>
               A <c>ParallelBZip2OutputStream</c> can be used only for
               <c>Write()</c> not for <c>Read()</c>.
             </para>
            
             </remarks>
            
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="offset">this is irrelevant, since it will always throw!</param>
            <param name="origin">this is irrelevant, since it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.SetLength(System.Int64)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="value">this is irrelevant, since it will always throw!</param>
        </member>
        <member name="M:Ionic.BZip2.ParallelBZip2OutputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="buffer">this parameter is never used</param>
            <param name="offset">this parameter is never used</param>
            <param name="count">this parameter is never used</param>
            <returns>never returns anything; always throws</returns>
        </member>
        <member name="P:Ionic.BZip2.ParallelBZip2OutputStream.MaxWorkers">
             <summary>
               The maximum number of concurrent compression worker threads to use.
             </summary>
            
             <remarks>
             <para>
               This property sets an upper limit on the number of concurrent worker
               threads to employ for compression. The implementation of this stream
               employs multiple threads from the .NET thread pool, via <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)">
               ThreadPool.QueueUserWorkItem()</see>, to compress the incoming data by
               block.  As each block of data is compressed, this stream re-orders the
               compressed blocks and writes them to the output stream.
             </para>
            
             <para>
               A higher number of workers enables a higher degree of
               parallelism, which tends to increase the speed of compression on
               multi-cpu computers.  On the other hand, a higher number of buffer
               pairs also implies a larger memory consumption, more active worker
               threads, and a higher cpu utilization for any compression. This
               property enables the application to limit its memory consumption and
               CPU utilization behavior depending on requirements.
             </para>
            
             <para>
               By default, DotNetZip allocates 4 workers per CPU core, subject to the
               upper limit specified in this property. For example, suppose the
               application sets this property to 16.  Then, on a machine with 2
               cores, DotNetZip will use 8 workers; that number does not exceed the
               upper limit specified by this property, so the actual number of
               workers used will be 4 * 2 = 8.  On a machine with 4 cores, DotNetZip
               will use 16 workers; again, the limit does not apply. On a machine
               with 8 cores, DotNetZip will use 16 workers, because of the limit.
             </para>
            
             <para>
               For each compression "worker thread" that occurs in parallel, there is
               up to 2mb of memory allocated, for buffering and processing. The
               actual number depends on the <see cref="P:Ionic.BZip2.ParallelBZip2OutputStream.BlockSize"/> property.
             </para>
            
             <para>
               CPU utilization will also go up with additional workers, because a
               larger number of buffer pairs allows a larger number of background
               threads to compress in parallel. If you find that parallel
               compression is consuming too much memory or CPU, you can adjust this
               value downward.
             </para>
            
             <para>
               The default value is 16. Different values may deliver better or
               worse results, depending on your priorities and the dynamic
               performance characteristics of your storage and compute resources.
             </para>
            
             <para>
               The application can set this value at any time, but it is effective
               only before the first call to Write(), which is when the buffers are
               allocated.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.BZip2.ParallelBZip2OutputStream.BlockSize">
            <summary>
              The blocksize parameter specified at construction time.
            </summary>
        </member>
        <member name="P:Ionic.BZip2.ParallelBZip2OutputStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value is always false.
            </remarks>
        </member>
        <member name="P:Ionic.BZip2.ParallelBZip2OutputStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.BZip2.ParallelBZip2OutputStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="P:Ionic.BZip2.ParallelBZip2OutputStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="P:Ionic.BZip2.ParallelBZip2OutputStream.Position">
             <summary>
             The position of the stream pointer.
             </summary>
            
             <remarks>
               Setting this property always throws a <see cref="T:System.NotImplementedException"/>. Reading will return the
               total number of uncompressed bytes written through.
             </remarks>
        </member>
        <member name="P:Ionic.BZip2.ParallelBZip2OutputStream.BytesWrittenOut">
            <summary>
            The total number of bytes written out by the stream.
            </summary>
            <remarks>
            This value is meaningful only after a call to Close().
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.Rand.Rnums(System.Int32)">
            <summary>
              Returns the "random" number at a specific index.
            </summary>
            <param name='i'>the index</param>
            <returns>the random number</returns>
        </member>
        <member name="T:Ionic.Zlib.DeflateStream">
             <summary>
             A class for compressing and decompressing streams using the Deflate algorithm.
             </summary>
            
             <remarks>
            
             <para>
               The DeflateStream is a <see href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a <see cref="T:System.IO.Stream"/>.  It adds DEFLATE compression or decompression to any
               stream.
             </para>
            
             <para>
               Using this stream, applications can compress or decompress data via stream
               <c>Read</c> and <c>Write</c> operations.  Either compresssion or decompression
               can occur through either reading or writing. The compression format used is
               DEFLATE, which is documented in <see href="http://www.ietf.org/rfc/rfc1951.txt">IETF RFC 1951</see>, "DEFLATE
               Compressed Data Format Specification version 1.3.".
             </para>
            
             <para>
               This class is similar to <see cref="T:Ionic.Zlib.ZlibStream"/>, except that
               <c>ZlibStream</c> adds the <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
               1950 - ZLIB</see> framing bytes to a compressed stream when compressing, or
               expects the RFC1950 framing bytes when decompressing. The <c>DeflateStream</c>
               does not.
             </para>
            
             </remarks>
            
             <seealso cref="T:Ionic.Zlib.ZlibStream"/>
             <seealso cref="T:Ionic.Zlib.GZipStream"/>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode)">
             <summary>
               Create a DeflateStream using the specified CompressionMode.
             </summary>
            
             <remarks>
               When mode is <c>CompressionMode.Compress</c>, the DeflateStream will use
               the default compression level. The "captive" stream will be closed when
               the DeflateStream is closed.
             </remarks>
            
             <example>
             This example uses a DeflateStream to compress data from a file, and writes
             the compressed data to another file.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".deflated"))
                 {
                     using (Stream compressor = new DeflateStream(raw, CompressionMode.Compress))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".deflated")
                     Using compressor As Stream = New DeflateStream(raw, CompressionMode.Compress)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel)">
             <summary>
             Create a DeflateStream using the specified CompressionMode and the specified CompressionLevel.
             </summary>
            
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Decompress</c>, the level parameter is
               ignored.  The "captive" stream will be closed when the DeflateStream is
               closed.
             </para>
            
             </remarks>
            
             <example>
            
               This example uses a DeflateStream to compress data from a file, and writes
               the compressed data to another file.
            
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".deflated"))
                 {
                     using (Stream compressor = new DeflateStream(raw,
                                                                  CompressionMode.Compress,
                                                                  CompressionLevel.BestCompression))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n= -1;
                         while (n != 0)
                         {
                             if (n &gt; 0)
                                 compressor.Write(buffer, 0, n);
                             n= input.Read(buffer, 0, buffer.Length);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".deflated")
                     Using compressor As Stream = New DeflateStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream to be read or written while deflating or inflating.</param>
             <param name="mode">Indicates whether the <c>DeflateStream</c> will compress or decompress.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,System.Boolean)">
             <summary>
               Create a <c>DeflateStream</c> using the specified
               <c>CompressionMode</c>, and explicitly specify whether the
               stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               memory stream that will be re-read after compression.  Specify true for
               the <paramref name="leaveOpen"/> parameter to leave the stream open.
             </para>
            
             <para>
               The <c>DeflateStream</c> will use the default compression level.
             </para>
            
             <para>
               See the other overloads of this constructor for example code.
             </para>
             </remarks>
            
             <param name="stream">
               The stream which will be read or written. This is called the
               "captive" stream in other places in this documentation.
             </param>
            
             <param name="mode">
               Indicates whether the <c>DeflateStream</c> will compress or decompress.
             </param>
            
             <param name="leaveOpen">true if the application would like the stream to
             remain open after inflation/deflation.</param>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel,System.Boolean)">
             <summary>
               Create a <c>DeflateStream</c> using the specified <c>CompressionMode</c>
               and the specified <c>CompressionLevel</c>, and explicitly specify whether
               the stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Decompress</c>, the level parameter is ignored.
             </para>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               <see cref="T:System.IO.MemoryStream"/> that will be re-read after
               compression.  Specify true for the <paramref name="leaveOpen"/> parameter
               to leave the stream open.
             </para>
            
             </remarks>
            
             <example>
            
               This example shows how to use a <c>DeflateStream</c> to compress data from
               a file, and store the compressed data into another file.
            
             <code>
             using (var output = System.IO.File.Create(fileToCompress + ".deflated"))
             {
                 using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
                 {
                     using (Stream compressor = new DeflateStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, true))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n= -1;
                         while (n != 0)
                         {
                             if (n &gt; 0)
                                 compressor.Write(buffer, 0, n);
                             n= input.Read(buffer, 0, buffer.Length);
                         }
                     }
                 }
                 // can write additional data to the output stream here
             }
             </code>
            
             <code lang="VB">
             Using output As FileStream = File.Create(fileToCompress &amp; ".deflated")
                 Using input As Stream = File.OpenRead(fileToCompress)
                     Using compressor As Stream = New DeflateStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, True)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
                 ' can write additional data to the output stream here.
             End Using
             </code>
             </example>
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
             <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.Dispose(System.Boolean)">
            <summary>
              Dispose the stream.
            </summary>
            <remarks>
              <para>
                This may or may not result in a <c>Close()</c> call on the captive
                stream.  See the constructors that have a <c>leaveOpen</c> parameter
                for more information.
              </para>
              <para>
                Application code won't call this code directly.  This method may be
                invoked in two distinct scenarios.  If disposing == true, the method
                has been called directly or indirectly by a user's code, for example
                via the public Dispose() method. In this case, both managed and
                unmanaged resources can be referenced and disposed.  If disposing ==
                false, the method has been called by the runtime from inside the
                object finalizer and this method should not reference other objects;
                in that case only unmanaged resources must be referenced or
                disposed.
              </para>
            </remarks>
            <param name="disposing">
              true if the Dispose method was invoked by user code.
            </param>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
             Read data from the stream.
             </summary>
             <remarks>
            
             <para>
               If you wish to use the <c>DeflateStream</c> to compress data while
               reading, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Compress</c>, providing an uncompressed data stream.
               Then call Read() on that <c>DeflateStream</c>, and the data read will be
               compressed as you read.  If you wish to use the <c>DeflateStream</c> to
               decompress data while reading, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Decompress</c>, providing a readable compressed data
               stream.  Then call Read() on that <c>DeflateStream</c>, and the data read
               will be decompressed as you read.
             </para>
            
             <para>
               A <c>DeflateStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but not both.
             </para>
            
             </remarks>
             <param name="buffer">The buffer into which the read data should be placed.</param>
             <param name="offset">the offset within that data array to put the first byte read.</param>
             <param name="count">the number of bytes to read.</param>
             <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="offset">this is irrelevant, since it will always throw!</param>
            <param name="origin">this is irrelevant, since it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.SetLength(System.Int64)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="value">this is irrelevant, since it will always throw!</param>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write data to the stream.
             </summary>
             <remarks>
            
             <para>
               If you wish to use the <c>DeflateStream</c> to compress data while
               writing, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Compress</c>, and a writable output stream.  Then call
               <c>Write()</c> on that <c>DeflateStream</c>, providing uncompressed data
               as input.  The data sent to the output stream will be the compressed form
               of the data written.  If you wish to use the <c>DeflateStream</c> to
               decompress data while writing, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Decompress</c>, and a writable output stream.  Then
               call <c>Write()</c> on that stream, providing previously compressed
               data. The data sent to the output stream will be the decompressed form of
               the data written.
             </para>
            
             <para>
               A <c>DeflateStream</c> can be used for <c>Read()</c> or <c>Write()</c>,
               but not both.
             </para>
            
             </remarks>
            
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.CompressString(System.String)">
             <summary>
               Compress a string into a byte array using DEFLATE (RFC 1951).
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:Ionic.Zlib.DeflateStream.UncompressString(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:Ionic.Zlib.DeflateStream.UncompressString(System.Byte[])">DeflateStream.UncompressString(byte[])</seealso>
             <seealso cref="M:Ionic.Zlib.DeflateStream.CompressBuffer(System.Byte[])">DeflateStream.CompressBuffer(byte[])</seealso>
             <seealso cref="M:Ionic.Zlib.GZipStream.CompressString(System.String)">GZipStream.CompressString(string)</seealso>
             <seealso cref="M:Ionic.Zlib.ZlibStream.CompressString(System.String)">ZlibStream.CompressString(string)</seealso>
            
             <param name="s">
               A string to compress. The string will first be encoded
               using UTF8, then compressed.
             </param>
            
             <returns>The string in compressed form</returns>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.CompressBuffer(System.Byte[])">
             <summary>
               Compress a byte array into a new byte array using DEFLATE.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:Ionic.Zlib.DeflateStream.UncompressBuffer(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:Ionic.Zlib.DeflateStream.CompressString(System.String)">DeflateStream.CompressString(string)</seealso>
             <seealso cref="M:Ionic.Zlib.DeflateStream.UncompressBuffer(System.Byte[])">DeflateStream.UncompressBuffer(byte[])</seealso>
             <seealso cref="M:Ionic.Zlib.GZipStream.CompressBuffer(System.Byte[])">GZipStream.CompressBuffer(byte[])</seealso>
             <seealso cref="M:Ionic.Zlib.ZlibStream.CompressBuffer(System.Byte[])">ZlibStream.CompressBuffer(byte[])</seealso>
            
             <param name="b">
               A buffer to compress.
             </param>
            
             <returns>The data in compressed form</returns>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.UncompressString(System.Byte[])">
             <summary>
               Uncompress a DEFLATE'd byte array into a single string.
             </summary>
            
             <seealso cref="M:Ionic.Zlib.DeflateStream.CompressString(System.String)">DeflateStream.CompressString(String)</seealso>
             <seealso cref="M:Ionic.Zlib.DeflateStream.UncompressBuffer(System.Byte[])">DeflateStream.UncompressBuffer(byte[])</seealso>
             <seealso cref="M:Ionic.Zlib.GZipStream.UncompressString(System.Byte[])">GZipStream.UncompressString(byte[])</seealso>
             <seealso cref="M:Ionic.Zlib.ZlibStream.UncompressString(System.Byte[])">ZlibStream.UncompressString(byte[])</seealso>
            
             <param name="compressed">
               A buffer containing DEFLATE-compressed data.
             </param>
            
             <returns>The uncompressed string</returns>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.UncompressBuffer(System.Byte[])">
             <summary>
               Uncompress a DEFLATE'd byte array into a byte array.
             </summary>
            
             <seealso cref="M:Ionic.Zlib.DeflateStream.CompressBuffer(System.Byte[])">DeflateStream.CompressBuffer(byte[])</seealso>
             <seealso cref="M:Ionic.Zlib.DeflateStream.UncompressString(System.Byte[])">DeflateStream.UncompressString(byte[])</seealso>
             <seealso cref="M:Ionic.Zlib.GZipStream.UncompressBuffer(System.Byte[])">GZipStream.UncompressBuffer(byte[])</seealso>
             <seealso cref="M:Ionic.Zlib.ZlibStream.UncompressBuffer(System.Byte[])">ZlibStream.UncompressBuffer(byte[])</seealso>
            
             <param name="compressed">
               A buffer containing data that has been compressed with DEFLATE.
             </param>
            
             <returns>The data in uncompressed form</returns>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.FlushMode">
            <summary>
            This property sets the flush behavior on the stream.
            </summary>
            <remarks> See the ZLIB documentation for the meaning of the flush behavior.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.BufferSize">
             <summary>
               The size of the working buffer for the compression codec.
             </summary>
            
             <remarks>
             <para>
               The working buffer is used for all stream operations.  The default size is
               1024 bytes.  The minimum size is 128 bytes. You may get better performance
               with a larger buffer.  Then again, you might not.  You would have to test
               it.
             </para>
            
             <para>
               Set this before the first call to <c>Read()</c> or <c>Write()</c> on the
               stream. If you try to set it afterwards, it will throw.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.Strategy">
             <summary>
               The ZLIB strategy to be used during compression.
             </summary>
            
             <remarks>
               By tweaking this parameter, you may be able to optimize the compression for
               data with particular characteristics.
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.Position">
             <summary>
             The position of the stream pointer.
             </summary>
            
             <remarks>
               Setting this property always throws a <see cref="T:System.NotImplementedException"/>. Reading will return the total bytes
               written out, if used in writing, or the total bytes read in, if used in
               reading.  The count may refer to compressed bytes or uncompressed bytes,
               depending on how you've used the stream.
             </remarks>
        </member>
        <member name="T:Ionic.Zlib.GZipStream">
             <summary>
               A class for compressing and decompressing GZIP streams.
             </summary>
             <remarks>
            
             <para>
               The <c>GZipStream</c> is a <see href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a
               <see cref="T:System.IO.Stream"/>. It adds GZIP compression or decompression to any
               stream.
             </para>
            
             <para>
               Like the <c>System.IO.Compression.GZipStream</c> in the .NET Base Class Library, the
               <c>Ionic.Zlib.GZipStream</c> can compress while writing, or decompress while
               reading, but not vice versa.  The compression method used is GZIP, which is
               documented in <see href="http://www.ietf.org/rfc/rfc1952.txt">IETF RFC
               1952</see>, "GZIP file format specification version 4.3".</para>
            
             <para>
               A <c>GZipStream</c> can be used to decompress data (through <c>Read()</c>) or
               to compress data (through <c>Write()</c>), but not both.
             </para>
            
             <para>
               If you wish to use the <c>GZipStream</c> to compress data, you must wrap it
               around a write-able stream. As you call <c>Write()</c> on the <c>GZipStream</c>, the
               data will be compressed into the GZIP format.  If you want to decompress data,
               you must wrap the <c>GZipStream</c> around a readable stream that contains an
               IETF RFC 1952-compliant stream.  The data will be decompressed as you call
               <c>Read()</c> on the <c>GZipStream</c>.
             </para>
            
             <para>
               Though the GZIP format allows data from multiple files to be concatenated
               together, this stream handles only a single segment of GZIP format, typically
               representing a single file.
             </para>
            
             <para>
               This class is similar to <see cref="T:Ionic.Zlib.ZlibStream"/> and <see cref="T:Ionic.Zlib.DeflateStream"/>.
               <c>ZlibStream</c> handles RFC1950-compliant streams.  <see cref="T:Ionic.Zlib.DeflateStream"/>
               handles RFC1951-compliant streams. This class handles RFC1952-compliant streams.
             </para>
            
             </remarks>
            
             <seealso cref="T:Ionic.Zlib.DeflateStream"/>
             <seealso cref="T:Ionic.Zlib.ZlibStream"/>
        </member>
        <member name="F:Ionic.Zlib.GZipStream.LastModified">
             <summary>
               The last modified time for the GZIP stream.
             </summary>
            
             <remarks>
               GZIP allows the storage of a last modified time with each GZIP entry.
               When compressing data, you can set this before the first call to
               <c>Write()</c>.  When decompressing, you can retrieve this value any time
               after the first call to <c>Read()</c>.
             </remarks>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c>.
             </summary>
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Compress</c>, the <c>GZipStream</c> will use the
               default compression level.
             </para>
            
             <para>
               As noted in the class documentation, the <c>CompressionMode</c> (Compress
               or Decompress) also establishes the "direction" of the stream.  A
               <c>GZipStream</c> with <c>CompressionMode.Compress</c> works only through
               <c>Write()</c>.  A <c>GZipStream</c> with
               <c>CompressionMode.Decompress</c> works only through <c>Read()</c>.
             </para>
            
             </remarks>
            
             <example>
               This example shows how to use a GZipStream to compress data.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(outputFile))
                 {
                     using (Stream compressor = new GZipStream(raw, CompressionMode.Compress))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             <code lang="VB">
             Dim outputFile As String = (fileToCompress &amp; ".compressed")
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(outputFile)
                 Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress)
                     Dim buffer As Byte() = New Byte(4096) {}
                     Dim n As Integer = -1
                     Do While (n &lt;&gt; 0)
                         If (n &gt; 0) Then
                             compressor.Write(buffer, 0, n)
                         End If
                         n = input.Read(buffer, 0, buffer.Length)
                     Loop
                 End Using
                 End Using
             End Using
             </code>
             </example>
            
             <example>
             This example shows how to use a GZipStream to uncompress a file.
             <code>
             private void GunZipFile(string filename)
             {
                 if (!filename.EndsWith(".gz))
                     throw new ArgumentException("filename");
                 var DecompressedFile = filename.Substring(0,filename.Length-3);
                 byte[] working = new byte[WORKING_BUFFER_SIZE];
                 int n= 1;
                 using (System.IO.Stream input = System.IO.File.OpenRead(filename))
                 {
                     using (Stream decompressor= new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, true))
                     {
                         using (var output = System.IO.File.Create(DecompressedFile))
                         {
                             while (n !=0)
                             {
                                 n= decompressor.Read(working, 0, working.Length);
                                 if (n > 0)
                                 {
                                     output.Write(working, 0, n);
                                 }
                             }
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Private Sub GunZipFile(ByVal filename as String)
                 If Not (filename.EndsWith(".gz)) Then
                     Throw New ArgumentException("filename")
                 End If
                 Dim DecompressedFile as String = filename.Substring(0,filename.Length-3)
                 Dim working(WORKING_BUFFER_SIZE) as Byte
                 Dim n As Integer = 1
                 Using input As Stream = File.OpenRead(filename)
                     Using decompressor As Stream = new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, True)
                         Using output As Stream = File.Create(UncompressedFile)
                             Do
                                 n= decompressor.Read(working, 0, working.Length)
                                 If n > 0 Then
                                     output.Write(working, 0, n)
                                 End IF
                             Loop While (n  > 0)
                         End Using
                     End Using
                 End Using
             End Sub
             </code>
             </example>
            
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the GZipStream will compress or decompress.</param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c> and
               the specified <c>CompressionLevel</c>.
             </summary>
             <remarks>
            
             <para>
               The <c>CompressionMode</c> (Compress or Decompress) also establishes the
               "direction" of the stream.  A <c>GZipStream</c> with
               <c>CompressionMode.Compress</c> works only through <c>Write()</c>.  A
               <c>GZipStream</c> with <c>CompressionMode.Decompress</c> works only
               through <c>Read()</c>.
             </para>
            
             </remarks>
            
             <example>
            
             This example shows how to use a <c>GZipStream</c> to compress a file into a .gz file.
            
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".gz"))
                 {
                     using (Stream compressor = new GZipStream(raw,
                                                               CompressionMode.Compress,
                                                               CompressionLevel.BestCompression))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".gz")
                     Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream to be read or written while deflating or inflating.</param>
             <param name="mode">Indicates whether the <c>GZipStream</c> will compress or decompress.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,System.Boolean)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c>, and
               explicitly specify whether the stream should be left open after Deflation
               or Inflation.
             </summary>
            
             <remarks>
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               memory stream that will be re-read after compressed data has been written
               to it.  Specify true for the <paramref name="leaveOpen"/> parameter to leave
               the stream open.
             </para>
            
             <para>
               The <see cref="T:Ionic.Zlib.CompressionMode"/> (Compress or Decompress) also
               establishes the "direction" of the stream.  A <c>GZipStream</c> with
               <c>CompressionMode.Compress</c> works only through <c>Write()</c>.  A <c>GZipStream</c>
               with <c>CompressionMode.Decompress</c> works only through <c>Read()</c>.
             </para>
            
             <para>
               The <c>GZipStream</c> will use the default compression level. If you want
               to specify the compression level, see <see cref="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel,System.Boolean)"/>.
             </para>
            
             <para>
               See the other overloads of this constructor for example code.
             </para>
            
             </remarks>
            
             <param name="stream">
               The stream which will be read or written. This is called the "captive"
               stream in other places in this documentation.
             </param>
            
             <param name="mode">Indicates whether the GZipStream will compress or decompress.
             </param>
            
             <param name="leaveOpen">
               true if the application would like the base stream to remain open after
               inflation/deflation.
             </param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel,System.Boolean)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c> and the
               specified <c>CompressionLevel</c>, and explicitly specify whether the
               stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               memory stream that will be re-read after compressed data has been written
               to it.  Specify true for the <paramref name="leaveOpen"/> parameter to
               leave the stream open.
             </para>
            
             <para>
               As noted in the class documentation, the <c>CompressionMode</c> (Compress
               or Decompress) also establishes the "direction" of the stream.  A
               <c>GZipStream</c> with <c>CompressionMode.Compress</c> works only through
               <c>Write()</c>.  A <c>GZipStream</c> with <c>CompressionMode.Decompress</c> works only
               through <c>Read()</c>.
             </para>
            
             </remarks>
            
             <example>
               This example shows how to use a <c>GZipStream</c> to compress data.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(outputFile))
                 {
                     using (Stream compressor = new GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression, true))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             <code lang="VB">
             Dim outputFile As String = (fileToCompress &amp; ".compressed")
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(outputFile)
                 Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression, True)
                     Dim buffer As Byte() = New Byte(4096) {}
                     Dim n As Integer = -1
                     Do While (n &lt;&gt; 0)
                         If (n &gt; 0) Then
                             compressor.Write(buffer, 0, n)
                         End If
                         n = input.Read(buffer, 0, buffer.Length)
                     Loop
                 End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the GZipStream will compress or decompress.</param>
             <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.Dispose(System.Boolean)">
            <summary>
              Dispose the stream.
            </summary>
            <remarks>
              <para>
                This may or may not result in a <c>Close()</c> call on the captive
                stream.  See the constructors that have a <c>leaveOpen</c> parameter
                for more information.
              </para>
              <para>
                This method may be invoked in two distinct scenarios.  If disposing
                == true, the method has been called directly or indirectly by a
                user's code, for example via the public Dispose() method. In this
                case, both managed and unmanaged resources can be referenced and
                disposed.  If disposing == false, the method has been called by the
                runtime from inside the object finalizer and this method should not
                reference other objects; in that case only unmanaged resources must
                be referenced or disposed.
              </para>
            </remarks>
            <param name="disposing">
              indicates whether the Dispose method was invoked by user code.
            </param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Read and decompress data from the source stream.
             </summary>
            
             <remarks>
               With a <c>GZipStream</c>, decompression is done through reading.
             </remarks>
            
             <example>
             <code>
             byte[] working = new byte[WORKING_BUFFER_SIZE];
             using (System.IO.Stream input = System.IO.File.OpenRead(_CompressedFile))
             {
                 using (Stream decompressor= new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, true))
                 {
                     using (var output = System.IO.File.Create(_DecompressedFile))
                     {
                         int n;
                         while ((n= decompressor.Read(working, 0, working.Length)) !=0)
                         {
                             output.Write(working, 0, n);
                         }
                     }
                 }
             }
             </code>
             </example>
             <param name="buffer">The buffer into which the decompressed data should be placed.</param>
             <param name="offset">the offset within that data array to put the first byte read.</param>
             <param name="count">the number of bytes to read.</param>
             <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
              Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="offset">irrelevant; it will always throw!</param>
            <param name="origin">irrelevant; it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.SetLength(System.Int64)">
            <summary>
              Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="value">irrelevant; this method will always throw!</param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write data to the stream.
             </summary>
            
             <remarks>
             <para>
               If you wish to use the <c>GZipStream</c> to compress data while writing,
               you can create a <c>GZipStream</c> with <c>CompressionMode.Compress</c>, and a
               writable output stream.  Then call <c>Write()</c> on that <c>GZipStream</c>,
               providing uncompressed data as input.  The data sent to the output stream
               will be the compressed form of the data written.
             </para>
            
             <para>
               A <c>GZipStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but not
               both. Writing implies compression.  Reading implies decompression.
             </para>
            
             </remarks>
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.CompressString(System.String)">
             <summary>
               Compress a string into a byte array using GZip.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:Ionic.Zlib.GZipStream.UncompressString(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:Ionic.Zlib.GZipStream.UncompressString(System.Byte[])"/>
             <seealso cref="M:Ionic.Zlib.GZipStream.CompressBuffer(System.Byte[])"/>
            
             <param name="s">
               A string to compress. The string will first be encoded
               using UTF8, then compressed.
             </param>
            
             <returns>The string in compressed form</returns>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.CompressBuffer(System.Byte[])">
             <summary>
               Compress a byte array into a new byte array using GZip.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:Ionic.Zlib.GZipStream.UncompressBuffer(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:Ionic.Zlib.GZipStream.CompressString(System.String)"/>
             <seealso cref="M:Ionic.Zlib.GZipStream.UncompressBuffer(System.Byte[])"/>
            
             <param name="b">
               A buffer to compress.
             </param>
            
             <returns>The data in compressed form</returns>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.UncompressString(System.Byte[])">
             <summary>
               Uncompress a GZip'ed byte array into a single string.
             </summary>
            
             <seealso cref="M:Ionic.Zlib.GZipStream.CompressString(System.String)"/>
             <seealso cref="M:Ionic.Zlib.GZipStream.UncompressBuffer(System.Byte[])"/>
            
             <param name="compressed">
               A buffer containing GZIP-compressed data.
             </param>
            
             <returns>The uncompressed string</returns>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.UncompressBuffer(System.Byte[])">
             <summary>
               Uncompress a GZip'ed byte array into a byte array.
             </summary>
            
             <seealso cref="M:Ionic.Zlib.GZipStream.CompressBuffer(System.Byte[])"/>
             <seealso cref="M:Ionic.Zlib.GZipStream.UncompressString(System.Byte[])"/>
            
             <param name="compressed">
               A buffer containing data that has been compressed with GZip.
             </param>
            
             <returns>The data in uncompressed form</returns>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.Comment">
             <summary>
               The comment on the GZIP stream.
             </summary>
            
             <remarks>
             <para>
               The GZIP format allows for each file to optionally have an associated
               comment stored with the file.  The comment is encoded with the ISO-8859-1
               code page.  To include a comment in a GZIP stream you create, set this
               property before calling <c>Write()</c> for the first time on the
               <c>GZipStream</c>.
             </para>
            
             <para>
               When using <c>GZipStream</c> to decompress, you can retrieve this property
               after the first call to <c>Read()</c>.  If no comment has been set in the
               GZIP bytestream, the Comment property will return <c>null</c>
               (<c>Nothing</c> in VB).
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.FileName">
             <summary>
               The FileName for the GZIP stream.
             </summary>
            
             <remarks>
            
             <para>
               The GZIP format optionally allows each file to have an associated
               filename.  When compressing data (through <c>Write()</c>), set this
               FileName before calling <c>Write()</c> the first time on the <c>GZipStream</c>.
               The actual filename is encoded into the GZIP bytestream with the
               ISO-8859-1 code page, according to RFC 1952. It is the application's
               responsibility to insure that the FileName can be encoded and decoded
               correctly with this code page.
             </para>
            
             <para>
               When decompressing (through <c>Read()</c>), you can retrieve this value
               any time after the first <c>Read()</c>.  In the case where there was no filename
               encoded into the GZIP bytestream, the property will return <c>null</c> (<c>Nothing</c>
               in VB).
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.Crc32">
            <summary>
            The CRC on the GZIP stream.
            </summary>
            <remarks>
            This is used for internal error checking. You probably don't need to look at this property.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.FlushMode">
            <summary>
            This property sets the flush behavior on the stream.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.BufferSize">
             <summary>
               The size of the working buffer for the compression codec.
             </summary>
            
             <remarks>
             <para>
               The working buffer is used for all stream operations.  The default size is
               1024 bytes.  The minimum size is 128 bytes. You may get better performance
               with a larger buffer.  Then again, you might not.  You would have to test
               it.
             </para>
            
             <para>
               Set this before the first call to <c>Read()</c> or <c>Write()</c> on the
               stream. If you try to set it afterwards, it will throw.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.Position">
             <summary>
               The position of the stream pointer.
             </summary>
            
             <remarks>
               Setting this property always throws a <see cref="T:System.NotImplementedException"/>. Reading will return the total bytes
               written out, if used in writing, or the total bytes read in, if used in
               reading.  The count may refer to compressed bytes or uncompressed bytes,
               depending on how you've used the stream.
             </remarks>
        </member>
        <member name="T:Ionic.Zlib.ParallelDeflateOutputStream">
             <summary>
               A class for compressing streams using the
               Deflate algorithm with multiple threads.
             </summary>
            
             <remarks>
             <para>
               This class performs DEFLATE compression through writing.  For
               more information on the Deflate algorithm, see IETF RFC 1951,
               "DEFLATE Compressed Data Format Specification version 1.3."
             </para>
            
             <para>
               This class is similar to <see cref="T:Ionic.Zlib.DeflateStream"/>, except
               that this class is for compression only, and this implementation uses an
               approach that employs multiple worker threads to perform the DEFLATE.  On
               a multi-cpu or multi-core computer, the performance of this class can be
               significantly higher than the single-threaded DeflateStream, particularly
               for larger streams.  How large?  Anything over 10mb is a good candidate
               for parallel compression.
             </para>
            
             <para>
               The tradeoff is that this class uses more memory and more CPU than the
               vanilla DeflateStream, and also is less efficient as a compressor. For
               large files the size of the compressed data stream can be less than 1%
               larger than the size of a compressed data stream from the vanialla
               DeflateStream.  For smaller files the difference can be larger.  The
               difference will also be larger if you set the BufferSize to be lower than
               the default value.  Your mileage may vary. Finally, for small files, the
               ParallelDeflateOutputStream can be much slower than the vanilla
               DeflateStream, because of the overhead associated to using the thread
               pool.
             </para>
            
             </remarks>
             <seealso cref="T:Ionic.Zlib.DeflateStream"/>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream)">
             <summary>
             Create a ParallelDeflateOutputStream.
             </summary>
             <remarks>
            
             <para>
               This stream compresses data written into it via the DEFLATE
               algorithm (see RFC 1951), and writes out the compressed byte stream.
             </para>
            
             <para>
               The instance will use the default compression level, the default
               buffer sizes and the default number of threads and buffers per
               thread.
             </para>
            
             <para>
               This class is similar to <see cref="T:Ionic.Zlib.DeflateStream"/>,
               except that this implementation uses an approach that employs
               multiple worker threads to perform the DEFLATE.  On a multi-cpu or
               multi-core computer, the performance of this class can be
               significantly higher than the single-threaded DeflateStream,
               particularly for larger streams.  How large?  Anything over 10mb is
               a good candidate for parallel compression.
             </para>
            
             </remarks>
            
             <example>
            
             This example shows how to use a ParallelDeflateOutputStream to compress
             data.  It reads a file, compresses it, and writes the compressed data to
             a second, output file.
            
             <code>
             byte[] buffer = new byte[WORKING_BUFFER_SIZE];
             int n= -1;
             String outputFile = fileToCompress + ".compressed";
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(outputFile))
                 {
                     using (Stream compressor = new ParallelDeflateOutputStream(raw))
                     {
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             <code lang="VB">
             Dim buffer As Byte() = New Byte(4096) {}
             Dim n As Integer = -1
             Dim outputFile As String = (fileToCompress &amp; ".compressed")
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(outputFile)
                     Using compressor As Stream = New ParallelDeflateOutputStream(raw)
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream to which compressed data will be written.</param>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionLevel)">
            <summary>
              Create a ParallelDeflateOutputStream using the specified CompressionLevel.
            </summary>
            <remarks>
              See the <see cref="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream)"/>
              constructor for example code.
            </remarks>
            <param name="stream">The stream to which compressed data will be written.</param>
            <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
            Create a ParallelDeflateOutputStream and specify whether to leave the captive stream open
            when the ParallelDeflateOutputStream is closed.
            </summary>
            <remarks>
              See the <see cref="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream)"/>
              constructor for example code.
            </remarks>
            <param name="stream">The stream to which compressed data will be written.</param>
            <param name="leaveOpen">
               true if the application would like the stream to remain open after inflation/deflation.
            </param>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionLevel,System.Boolean)">
            <summary>
            Create a ParallelDeflateOutputStream and specify whether to leave the captive stream open
            when the ParallelDeflateOutputStream is closed.
            </summary>
            <remarks>
              See the <see cref="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream)"/>
              constructor for example code.
            </remarks>
            <param name="stream">The stream to which compressed data will be written.</param>
            <param name="level">A tuning knob to trade speed for effectiveness.</param>
            <param name="leaveOpen">
               true if the application would like the stream to remain open after inflation/deflation.
            </param>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionLevel,Ionic.Zlib.CompressionStrategy,System.Boolean)">
            <summary>
            Create a ParallelDeflateOutputStream using the specified
            CompressionLevel and CompressionStrategy, and specifying whether to
            leave the captive stream open when the ParallelDeflateOutputStream is
            closed.
            </summary>
            <remarks>
              See the <see cref="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream)"/>
              constructor for example code.
            </remarks>
            <param name="stream">The stream to which compressed data will be written.</param>
            <param name="level">A tuning knob to trade speed for effectiveness.</param>
            <param name="strategy">
              By tweaking this parameter, you may be able to optimize the compression for
              data with particular characteristics.
            </param>
            <param name="leaveOpen">
               true if the application would like the stream to remain open after inflation/deflation.
            </param>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write data to the stream.
             </summary>
            
             <remarks>
            
             <para>
               To use the ParallelDeflateOutputStream to compress data, create a
               ParallelDeflateOutputStream with CompressionMode.Compress, passing a
               writable output stream.  Then call Write() on that
               ParallelDeflateOutputStream, providing uncompressed data as input.  The
               data sent to the output stream will be the compressed form of the data
               written.
             </para>
            
             <para>
               To decompress data, use the <see cref="T:Ionic.Zlib.DeflateStream"/> class.
             </para>
            
             </remarks>
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Close">
            <summary>
            Close the stream.
            </summary>
            <remarks>
            You must call Close on the stream to guarantee that all of the data written in has
            been compressed, and the compressed data has been written out.
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Dispose">
            <summary>Dispose the object</summary>
            <remarks>
              <para>
                Because ParallelDeflateOutputStream is IDisposable, the
                application must call this method when finished using the instance.
              </para>
              <para>
                This method is generally called implicitly upon exit from
                a <c>using</c> scope in C# (<c>Using</c> in VB).
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Dispose(System.Boolean)">
            <summary>The Dispose method</summary>
            <param name="disposing">
              indicates whether the Dispose method was invoked by user code.
            </param>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Reset(System.IO.Stream)">
             <summary>
               Resets the stream for use with another stream.
             </summary>
             <remarks>
               Because the ParallelDeflateOutputStream is expensive to create, it
               has been designed so that it can be recycled and re-used.  You have
               to call Close() on the stream first, then you can call Reset() on
               it, to use it again on another stream.
             </remarks>
            
             <param name="stream">
               The new output stream for this era.
             </param>
            
             <example>
             <code>
             ParallelDeflateOutputStream deflater = null;
             foreach (var inputFile in listOfFiles)
             {
                 string outputFile = inputFile + ".compressed";
                 using (System.IO.Stream input = System.IO.File.OpenRead(inputFile))
                 {
                     using (var outStream = System.IO.File.Create(outputFile))
                     {
                         if (deflater == null)
                             deflater = new ParallelDeflateOutputStream(outStream,
                                                                        CompressionLevel.Best,
                                                                        CompressionStrategy.Default,
                                                                        true);
                         deflater.Reset(outStream);
            
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             deflater.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             </example>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            This method always throws a NotSupportedException.
            </summary>
            <param name="buffer">
              The buffer into which data would be read, IF THIS METHOD
              ACTUALLY DID ANYTHING.
            </param>
            <param name="offset">
              The offset within that data array at which to insert the
              data that is read, IF THIS METHOD ACTUALLY DID
              ANYTHING.
            </param>
            <param name="count">
              The number of bytes to write, IF THIS METHOD ACTUALLY DID
              ANYTHING.
            </param>
            <returns>nothing.</returns>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            This method always throws a NotSupportedException.
            </summary>
            <param name="offset">
              The offset to seek to....
              IF THIS METHOD ACTUALLY DID ANYTHING.
            </param>
            <param name="origin">
              The reference specifying how to apply the offset....  IF
              THIS METHOD ACTUALLY DID ANYTHING.
            </param>
            <returns>nothing. It always throws.</returns>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.SetLength(System.Int64)">
            <summary>
            This method always throws a NotSupportedException.
            </summary>
            <param name="value">
              The new value for the stream length....  IF
              THIS METHOD ACTUALLY DID ANYTHING.
            </param>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.Strategy">
             <summary>
               The ZLIB strategy to be used during compression.
             </summary>
            
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.MaxBufferPairs">
             <summary>
               The maximum number of buffer pairs to use.
             </summary>
            
             <remarks>
             <para>
               This property sets an upper limit on the number of memory buffer
               pairs to create.  The implementation of this stream allocates
               multiple buffers to facilitate parallel compression.  As each buffer
               fills up, this stream uses <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)">
               ThreadPool.QueueUserWorkItem()</see>
               to compress those buffers in a background threadpool thread. After a
               buffer is compressed, it is re-ordered and written to the output
               stream.
             </para>
            
             <para>
               A higher number of buffer pairs enables a higher degree of
               parallelism, which tends to increase the speed of compression on
               multi-cpu computers.  On the other hand, a higher number of buffer
               pairs also implies a larger memory consumption, more active worker
               threads, and a higher cpu utilization for any compression. This
               property enables the application to limit its memory consumption and
               CPU utilization behavior depending on requirements.
             </para>
            
             <para>
               For each compression "task" that occurs in parallel, there are 2
               buffers allocated: one for input and one for output.  This property
               sets a limit for the number of pairs.  The total amount of storage
               space allocated for buffering will then be (N*S*2), where N is the
               number of buffer pairs, S is the size of each buffer (<see cref="P:Ionic.Zlib.ParallelDeflateOutputStream.BufferSize"/>).  By default, DotNetZip allocates 4 buffer
               pairs per CPU core, so if your machine has 4 cores, and you retain
               the default buffer size of 128k, then the
               ParallelDeflateOutputStream will use 4 * 4 * 2 * 128kb of buffer
               memory in total, or 4mb, in blocks of 128kb.  If you then set this
               property to 8, then the number will be 8 * 2 * 128kb of buffer
               memory, or 2mb.
             </para>
            
             <para>
               CPU utilization will also go up with additional buffers, because a
               larger number of buffer pairs allows a larger number of background
               threads to compress in parallel. If you find that parallel
               compression is consuming too much memory or CPU, you can adjust this
               value downward.
             </para>
            
             <para>
               The default value is 16. Different values may deliver better or
               worse results, depending on your priorities and the dynamic
               performance characteristics of your storage and compute resources.
             </para>
            
             <para>
               This property is not the number of buffer pairs to use; it is an
               upper limit. An illustration: Suppose you have an application that
               uses the default value of this property (which is 16), and it runs
               on a machine with 2 CPU cores. In that case, DotNetZip will allocate
               4 buffer pairs per CPU core, for a total of 8 pairs.  The upper
               limit specified by this property has no effect.
             </para>
            
             <para>
               The application can set this value at any time, but it is effective
               only before the first call to Write(), which is when the buffers are
               allocated.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.BufferSize">
             <summary>
               The size of the buffers used by the compressor threads.
             </summary>
             <remarks>
            
             <para>
               The default buffer size is 128k. The application can set this value
               at any time, but it is effective only before the first Write().
             </para>
            
             <para>
               Larger buffer sizes implies larger memory consumption but allows
               more efficient compression. Using smaller buffer sizes consumes less
               memory but may result in less effective compression.  For example,
               using the default buffer size of 128k, the compression delivered is
               within 1% of the compression delivered by the single-threaded <see cref="T:Ionic.Zlib.DeflateStream"/>.  On the other hand, using a
               BufferSize of 8k can result in a compressed data stream that is 5%
               larger than that delivered by the single-threaded
               <c>DeflateStream</c>.  Excessively small buffer sizes can also cause
               the speed of the ParallelDeflateOutputStream to drop, because of
               larger thread scheduling overhead dealing with many many small
               buffers.
             </para>
            
             <para>
               The total amount of storage space allocated for buffering will be
               (N*S*2), where N is the number of buffer pairs, and S is the size of
               each buffer (this property). There are 2 buffers used by the
               compressor, one for input and one for output.  By default, DotNetZip
               allocates 4 buffer pairs per CPU core, so if your machine has 4
               cores, then the number of buffer pairs used will be 16. If you
               accept the default value of this property, 128k, then the
               ParallelDeflateOutputStream will use 16 * 2 * 128kb of buffer memory
               in total, or 4mb, in blocks of 128kb.  If you set this property to
               64kb, then the number will be 16 * 2 * 64kb of buffer memory, or
               2mb.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.Crc32">
            <summary>
            The CRC32 for the data that was written out, prior to compression.
            </summary>
            <remarks>
            This value is meaningful only after a call to Close().
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.BytesProcessed">
            <summary>
            The total number of uncompressed bytes processed by the ParallelDeflateOutputStream.
            </summary>
            <remarks>
            This value is meaningful only after a call to Close().
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.CanRead">
            <summary>
            Indicates whether the stream supports Read operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.CanWrite">
            <summary>
            Indicates whether the stream supports Write operations.
            </summary>
            <remarks>
            Returns true if the provided stream is writable.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.Length">
            <summary>
            Reading this property always throws a NotSupportedException.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.Position">
            <summary>
            Returns the current position of the output stream.
            </summary>
            <remarks>
              <para>
                Because the output gets written by a background thread,
                the value may change asynchronously.  Setting this
                property always throws a NotSupportedException.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.Tree.DistanceCode(System.Int32)">
            <summary>
            Map from a distance to a distance code.
            </summary>
            <remarks> 
            No side effects. _dist_code[256] and _dist_code[257] are never used.
            </remarks>
        </member>
        <member name="T:Ionic.Zlib.FlushType">
            <summary>
            Describes how to flush the current deflate operation.
            </summary>
            <remarks>
            The different FlushType values are useful when using a Deflate in a streaming application.
            </remarks>
        </member>
        <member name="F:Ionic.Zlib.FlushType.None">
            <summary>No flush at all.</summary>
        </member>
        <member name="F:Ionic.Zlib.FlushType.Partial">
            <summary>Closes the current block, but doesn't flush it to
            the output. Used internally only in hypothetical
            scenarios.  This was supposed to be removed by Zlib, but it is
            still in use in some edge cases.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.FlushType.Sync">
            <summary>
            Use this during compression to specify that all pending output should be
            flushed to the output buffer and the output should be aligned on a byte
            boundary.  You might use this in a streaming communication scenario, so that
            the decompressor can get all input data available so far.  When using this
            with a ZlibCodec, <c>AvailableBytesIn</c> will be zero after the call if
            enough output space has been provided before the call.  Flushing will
            degrade compression and so it should be used only when necessary.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.FlushType.Full">
            <summary>
            Use this during compression to specify that all output should be flushed, as
            with <c>FlushType.Sync</c>, but also, the compression state should be reset
            so that decompression can restart from this point if previous compressed
            data has been damaged or if random access is desired.  Using
            <c>FlushType.Full</c> too often can significantly degrade the compression.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.FlushType.Finish">
            <summary>Signals the end of the compression/decompression stream.</summary>
        </member>
        <member name="T:Ionic.Zlib.CompressionLevel">
            <summary>
            The compression level to be used when using a DeflateStream or ZlibStream with CompressionMode.Compress.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.None">
            <summary>
            None means that the data will be simply stored, with no change at all.
            If you are producing ZIPs for use on Mac OSX, be aware that archives produced with CompressionLevel.None
            cannot be opened with the default zip reader. Use a different CompressionLevel.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level0">
            <summary>
            Same as None.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.BestSpeed">
            <summary>
            The fastest but least effective compression.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level1">
            <summary>
            A synonym for BestSpeed.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level2">
            <summary>
            A little slower, but better, than level 1.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level3">
            <summary>
            A little slower, but better, than level 2.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level4">
            <summary>
            A little slower, but better, than level 3.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level5">
            <summary>
            A little slower than level 4, but with better compression.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Default">
            <summary>
            The default compression level, with a good balance of speed and compression efficiency.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level6">
            <summary>
            A synonym for Default.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level7">
            <summary>
            Pretty good compression!
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level8">
            <summary>
             Better compression than Level7!
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.BestCompression">
            <summary>
            The "best" compression, where best means greatest reduction in size of the input data stream.
            This is also the slowest compression.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level9">
            <summary>
            A synonym for BestCompression.
            </summary>
        </member>
        <member name="T:Ionic.Zlib.CompressionStrategy">
            <summary>
            Describes options for how the compression algorithm is executed.  Different strategies
            work better on different sorts of data.  The strategy parameter can affect the compression
            ratio and the speed of compression but not the correctness of the compresssion.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionStrategy.Default">
            <summary>
            The default strategy is probably the best for normal data.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionStrategy.Filtered">
            <summary>
            The <c>Filtered</c> strategy is intended to be used most effectively with data produced by a
            filter or predictor.  By this definition, filtered data consists mostly of small
            values with a somewhat random distribution.  In this case, the compression algorithm
            is tuned to compress them better.  The effect of <c>Filtered</c> is to force more Huffman
            coding and less string matching; it is a half-step between <c>Default</c> and <c>HuffmanOnly</c>.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionStrategy.HuffmanOnly">
            <summary>
            Using <c>HuffmanOnly</c> will force the compressor to do Huffman encoding only, with no
            string matching.
            </summary>
        </member>
        <member name="T:Ionic.Zlib.CompressionMode">
            <summary>
            An enum to specify the direction of transcoding - whether to compress or decompress.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionMode.Compress">
            <summary>
            Used to specify that the stream should compress the data.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionMode.Decompress">
            <summary>
            Used to specify that the stream should decompress the data.
            </summary>
        </member>
        <member name="T:Ionic.Zlib.ZlibException">
            <summary>
            A general purpose exception class for exceptions in the Zlib library.
            </summary>
        </member>
        <member name="M:Ionic.Zlib.ZlibException.#ctor">
            <summary>
            The ZlibException class captures exception information generated
            by the Zlib library.
            </summary>
        </member>
        <member name="M:Ionic.Zlib.ZlibException.#ctor(System.String)">
            <summary>
            This ctor collects a message attached to the exception.
            </summary>
            <param name="s">the message for the exception.</param>
        </member>
        <member name="M:Ionic.Zlib.SharedUtils.URShift(System.Int32,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:Ionic.Zlib.SharedUtils.ReadInput(System.IO.TextReader,System.Byte[],System.Int32,System.Int32)">
             <summary>
               Reads a number of characters from the current source TextReader and writes
               the data to the target array at the specified index.
             </summary>
            
             <param name="sourceTextReader">The source TextReader to read from</param>
             <param name="target">Contains the array of characteres read from the source TextReader.</param>
             <param name="start">The starting index of the target array.</param>
             <param name="count">The maximum number of characters to read from the source TextReader.</param>
            
             <returns>
               The number of characters read. The number will be less than or equal to
               count depending on the data available in the source TextReader. Returns -1
               if the end of the stream is reached.
             </returns>
        </member>
        <member name="T:Ionic.Zlib.Adler">
             <summary>
             Computes an Adler-32 checksum.
             </summary>
             <remarks>
             The Adler checksum is similar to a CRC checksum, but faster to compute, though less
             reliable.  It is used in producing RFC1950 compressed streams.  The Adler checksum
             is a required part of the "ZLIB" standard.  Applications will almost never need to
             use this class directly.
             </remarks>
            
             <exclude/>
        </member>
        <member name="M:Ionic.Zlib.Adler.Adler32(System.UInt32,System.Byte[],System.Int32,System.Int32)">
            <summary>
              Calculates the Adler32 checksum.
            </summary>
            <remarks>
              <para>
                This is used within ZLIB.  You probably don't need to use this directly.
              </para>
            </remarks>
            <example>
               To compute an Adler32 checksum on a byte array:
             <code>
               var adler = Adler.Adler32(0, null, 0, 0);
               adler = Adler.Adler32(adler, buffer, index, length);
             </code>
            </example>
        </member>
        <member name="T:Ionic.Zlib.ZlibCodec">
             <summary>
             Encoder and Decoder for ZLIB and DEFLATE (IETF RFC1950 and RFC1951).
             </summary>
            
             <remarks>
             This class compresses and decompresses data according to the Deflate algorithm
             and optionally, the ZLIB format, as documented in <see
             href="http://www.ietf.org/rfc/rfc1950.txt">RFC 1950 - ZLIB</see> and <see
             href="http://www.ietf.org/rfc/rfc1951.txt">RFC 1951 - DEFLATE</see>.
             </remarks>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.InputBuffer">
            <summary>
            The buffer from which data is taken.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.NextIn">
            <summary>
            An index into the InputBuffer array, indicating where to start reading. 
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.AvailableBytesIn">
            <summary>
            The number of bytes available in the InputBuffer, starting at NextIn. 
            </summary>
            <remarks>
            Generally you should set this to InputBuffer.Length before the first Inflate() or Deflate() call. 
            The class will update this number as calls to Inflate/Deflate are made.
            </remarks>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.TotalBytesIn">
            <summary>
            Total number of bytes read so far, through all calls to Inflate()/Deflate().
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.OutputBuffer">
            <summary>
            Buffer to store output data.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.NextOut">
            <summary>
            An index into the OutputBuffer array, indicating where to start writing. 
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.AvailableBytesOut">
            <summary>
            The number of bytes available in the OutputBuffer, starting at NextOut. 
            </summary>
            <remarks>
            Generally you should set this to OutputBuffer.Length before the first Inflate() or Deflate() call. 
            The class will update this number as calls to Inflate/Deflate are made.
            </remarks>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.TotalBytesOut">
            <summary>
            Total number of bytes written to the output so far, through all calls to Inflate()/Deflate().
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.Message">
            <summary>
            used for diagnostics, when something goes wrong!
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.CompressLevel">
            <summary>
            The compression level to use in this codec.  Useful only in compression mode.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.WindowBits">
            <summary>
            The number of Window Bits to use.  
            </summary>
            <remarks>
            This gauges the size of the sliding window, and hence the 
            compression effectiveness as well as memory consumption. It's best to just leave this 
            setting alone if you don't know what it is.  The maximum value is 15 bits, which implies
            a 32k window.  
            </remarks>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.Strategy">
            <summary>
            The compression strategy to use.
            </summary>
            <remarks>
            This is only effective in compression.  The theory offered by ZLIB is that different
            strategies could potentially produce significant differences in compression behavior
            for different data sets.  Unfortunately I don't have any good recommendations for how
            to set it differently.  When I tested changing the strategy I got minimally different
            compression performance. It's best to leave this property alone if you don't have a
            good feel for it.  Or, you may want to produce a test harness that runs through the
            different strategy options and evaluates them on different file types. If you do that,
            let me know your results.
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.#ctor">
            <summary>
            Create a ZlibCodec.
            </summary>
            <remarks>
            If you use this default constructor, you will later have to explicitly call 
            InitializeInflate() or InitializeDeflate() before using the ZlibCodec to compress 
            or decompress. 
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.#ctor(Ionic.Zlib.CompressionMode)">
            <summary>
            Create a ZlibCodec that either compresses or decompresses.
            </summary>
            <param name="mode">
            Indicates whether the codec should compress (deflate) or decompress (inflate).
            </param>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeInflate">
            <summary>
            Initialize the inflation state. 
            </summary>
            <remarks>
            It is not necessary to call this before using the ZlibCodec to inflate data; 
            It is implicitly called when you call the constructor.
            </remarks>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeInflate(System.Boolean)">
             <summary>
             Initialize the inflation state with an explicit flag to
             govern the handling of RFC1950 header bytes.
             </summary>
            
             <remarks>
             By default, the ZLIB header defined in <see
             href="http://www.ietf.org/rfc/rfc1950.txt">RFC 1950</see> is expected.  If
             you want to read a zlib stream you should specify true for
             expectRfc1950Header.  If you have a deflate stream, you will want to specify
             false. It is only necessary to invoke this initializer explicitly if you
             want to specify false.
             </remarks>
            
             <param name="expectRfc1950Header">whether to expect an RFC1950 header byte
             pair when reading the stream of data to be inflated.</param>
            
             <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeInflate(System.Int32)">
            <summary>
            Initialize the ZlibCodec for inflation, with the specified number of window bits. 
            </summary>
            <param name="windowBits">The number of window bits to use. If you need to ask what that is, 
            then you shouldn't be calling this initializer.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeInflate(System.Int32,System.Boolean)">
             <summary>
             Initialize the inflation state with an explicit flag to govern the handling of
             RFC1950 header bytes. 
             </summary>
            
             <remarks>
             If you want to read a zlib stream you should specify true for
             expectRfc1950Header. In this case, the library will expect to find a ZLIB
             header, as defined in <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
             1950</see>, in the compressed stream.  If you will be reading a DEFLATE or
             GZIP stream, which does not have such a header, you will want to specify
             false.
             </remarks>
            
             <param name="expectRfc1950Header">whether to expect an RFC1950 header byte pair when reading 
             the stream of data to be inflated.</param>
             <param name="windowBits">The number of window bits to use. If you need to ask what that is, 
             then you shouldn't be calling this initializer.</param>
             <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.Inflate(Ionic.Zlib.FlushType)">
             <summary>
             Inflate the data in the InputBuffer, placing the result in the OutputBuffer.
             </summary>
             <remarks>
             You must have set InputBuffer and OutputBuffer, NextIn and NextOut, and AvailableBytesIn and 
             AvailableBytesOut  before calling this method.
             </remarks>
             <example>
             <code>
             private void InflateBuffer()
             {
                 int bufferSize = 1024;
                 byte[] buffer = new byte[bufferSize];
                 ZlibCodec decompressor = new ZlibCodec();
             
                 Console.WriteLine("\n============================================");
                 Console.WriteLine("Size of Buffer to Inflate: {0} bytes.", CompressedBytes.Length);
                 MemoryStream ms = new MemoryStream(DecompressedBytes);
             
                 int rc = decompressor.InitializeInflate();
             
                 decompressor.InputBuffer = CompressedBytes;
                 decompressor.NextIn = 0;
                 decompressor.AvailableBytesIn = CompressedBytes.Length;
             
                 decompressor.OutputBuffer = buffer;
             
                 // pass 1: inflate 
                 do
                 {
                     decompressor.NextOut = 0;
                     decompressor.AvailableBytesOut = buffer.Length;
                     rc = decompressor.Inflate(FlushType.None);
             
                     if (rc != ZlibConstants.Z_OK &amp;&amp; rc != ZlibConstants.Z_STREAM_END)
                         throw new Exception("inflating: " + decompressor.Message);
             
                     ms.Write(decompressor.OutputBuffer, 0, buffer.Length - decompressor.AvailableBytesOut);
                 }
                 while (decompressor.AvailableBytesIn &gt; 0 || decompressor.AvailableBytesOut == 0);
             
                 // pass 2: finish and flush
                 do
                 {
                     decompressor.NextOut = 0;
                     decompressor.AvailableBytesOut = buffer.Length;
                     rc = decompressor.Inflate(FlushType.Finish);
             
                     if (rc != ZlibConstants.Z_STREAM_END &amp;&amp; rc != ZlibConstants.Z_OK)
                         throw new Exception("inflating: " + decompressor.Message);
             
                     if (buffer.Length - decompressor.AvailableBytesOut &gt; 0)
                         ms.Write(buffer, 0, buffer.Length - decompressor.AvailableBytesOut);
                 }
                 while (decompressor.AvailableBytesIn &gt; 0 || decompressor.AvailableBytesOut == 0);
             
                 decompressor.EndInflate();
             }
            
             </code>
             </example>
             <param name="flush">The flush to use when inflating.</param>
             <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.EndInflate">
            <summary>
            Ends an inflation session. 
            </summary>
            <remarks>
            Call this after successively calling Inflate().  This will cause all buffers to be flushed. 
            After calling this you cannot call Inflate() without a intervening call to one of the
            InitializeInflate() overloads.
            </remarks>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.SyncInflate">
            <summary>
            I don't know what this does!
            </summary>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate">
            <summary>
            Initialize the ZlibCodec for deflation operation.
            </summary>
            <remarks>
            The codec will use the MAX window bits and the default level of compression.
            </remarks>
            <example>
            <code>
             int bufferSize = 40000;
             byte[] CompressedBytes = new byte[bufferSize];
             byte[] DecompressedBytes = new byte[bufferSize];
             
             ZlibCodec compressor = new ZlibCodec();
             
             compressor.InitializeDeflate(CompressionLevel.Default);
             
             compressor.InputBuffer = System.Text.ASCIIEncoding.ASCII.GetBytes(TextToCompress);
             compressor.NextIn = 0;
             compressor.AvailableBytesIn = compressor.InputBuffer.Length;
             
             compressor.OutputBuffer = CompressedBytes;
             compressor.NextOut = 0;
             compressor.AvailableBytesOut = CompressedBytes.Length;
             
             while (compressor.TotalBytesIn != TextToCompress.Length &amp;&amp; compressor.TotalBytesOut &lt; bufferSize)
             {
               compressor.Deflate(FlushType.None);
             }
             
             while (true)
             {
               int rc= compressor.Deflate(FlushType.Finish);
               if (rc == ZlibConstants.Z_STREAM_END) break;
             }
             
             compressor.EndDeflate();
              
            </code>
            </example>
            <returns>Z_OK if all goes well. You generally don't need to check the return code.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate(Ionic.Zlib.CompressionLevel)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel.
            </summary>
            <remarks>
            The codec will use the maximum window bits (15) and the specified
            CompressionLevel.  It will emit a ZLIB stream as it compresses.
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate(Ionic.Zlib.CompressionLevel,System.Boolean)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel, 
            and the explicit flag governing whether to emit an RFC1950 header byte pair.
            </summary>
            <remarks>
            The codec will use the maximum window bits (15) and the specified CompressionLevel.
            If you want to generate a zlib stream, you should specify true for
            wantRfc1950Header. In this case, the library will emit a ZLIB
            header, as defined in <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
            1950</see>, in the compressed stream.  
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <param name="wantRfc1950Header">whether to emit an initial RFC1950 byte pair in the compressed stream.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate(Ionic.Zlib.CompressionLevel,System.Int32)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel, 
            and the specified number of window bits. 
            </summary>
            <remarks>
            The codec will use the specified number of window bits and the specified CompressionLevel.
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <param name="bits">the number of window bits to use.  If you don't know what this means, don't use this method.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate(Ionic.Zlib.CompressionLevel,System.Int32,System.Boolean)">
             <summary>
             Initialize the ZlibCodec for deflation operation, using the specified
             CompressionLevel, the specified number of window bits, and the explicit flag
             governing whether to emit an RFC1950 header byte pair.
             </summary>
            
             <param name="level">The compression level for the codec.</param>
             <param name="wantRfc1950Header">whether to emit an initial RFC1950 byte pair in the compressed stream.</param>
             <param name="bits">the number of window bits to use.  If you don't know what this means, don't use this method.</param>
             <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.Deflate(Ionic.Zlib.FlushType)">
            <summary>
            Deflate one batch of data.
            </summary>
            <remarks>
            You must have set InputBuffer and OutputBuffer before calling this method.
            </remarks>
            <example>
            <code>
            private void DeflateBuffer(CompressionLevel level)
            {
                int bufferSize = 1024;
                byte[] buffer = new byte[bufferSize];
                ZlibCodec compressor = new ZlibCodec();
            
                Console.WriteLine("\n============================================");
                Console.WriteLine("Size of Buffer to Deflate: {0} bytes.", UncompressedBytes.Length);
                MemoryStream ms = new MemoryStream();
            
                int rc = compressor.InitializeDeflate(level);
            
                compressor.InputBuffer = UncompressedBytes;
                compressor.NextIn = 0;
                compressor.AvailableBytesIn = UncompressedBytes.Length;
            
                compressor.OutputBuffer = buffer;
            
                // pass 1: deflate 
                do
                {
                    compressor.NextOut = 0;
                    compressor.AvailableBytesOut = buffer.Length;
                    rc = compressor.Deflate(FlushType.None);
            
                    if (rc != ZlibConstants.Z_OK &amp;&amp; rc != ZlibConstants.Z_STREAM_END)
                        throw new Exception("deflating: " + compressor.Message);
            
                    ms.Write(compressor.OutputBuffer, 0, buffer.Length - compressor.AvailableBytesOut);
                }
                while (compressor.AvailableBytesIn &gt; 0 || compressor.AvailableBytesOut == 0);
            
                // pass 2: finish and flush
                do
                {
                    compressor.NextOut = 0;
                    compressor.AvailableBytesOut = buffer.Length;
                    rc = compressor.Deflate(FlushType.Finish);
            
                    if (rc != ZlibConstants.Z_STREAM_END &amp;&amp; rc != ZlibConstants.Z_OK)
                        throw new Exception("deflating: " + compressor.Message);
            
                    if (buffer.Length - compressor.AvailableBytesOut &gt; 0)
                        ms.Write(buffer, 0, buffer.Length - compressor.AvailableBytesOut);
                }
                while (compressor.AvailableBytesIn &gt; 0 || compressor.AvailableBytesOut == 0);
            
                compressor.EndDeflate();
            
                ms.Seek(0, SeekOrigin.Begin);
                CompressedBytes = new byte[compressor.TotalBytesOut];
                ms.Read(CompressedBytes, 0, CompressedBytes.Length);
            }
            </code>
            </example>
            <param name="flush">whether to flush all data as you deflate. Generally you will want to 
            use Z_NO_FLUSH here, in a series of calls to Deflate(), and then call EndDeflate() to 
            flush everything. 
            </param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.EndDeflate">
            <summary>
            End a deflation session.
            </summary>
            <remarks>
            Call this after making a series of one or more calls to Deflate(). All buffers are flushed.
            </remarks>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.ResetDeflate">
            <summary>
            Reset a codec for another deflation session.
            </summary>
            <remarks>
            Call this to reset the deflation state.  For example if a thread is deflating
            non-consecutive blocks, you can call Reset() after the Deflate(Sync) of the first
            block and before the next Deflate(None) of the second block.
            </remarks>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.SetDeflateParams(Ionic.Zlib.CompressionLevel,Ionic.Zlib.CompressionStrategy)">
            <summary>
            Set the CompressionStrategy and CompressionLevel for a deflation session.
            </summary>
            <param name="level">the level of compression to use.</param>
            <param name="strategy">the strategy to use for compression.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.SetDictionary(System.Byte[])">
            <summary>
            Set the dictionary to be used for either Inflation or Deflation.
            </summary>
            <param name="dictionary">The dictionary bytes to use.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="P:Ionic.Zlib.ZlibCodec.Adler32">
            <summary>
            The Adler32 checksum on the data transferred through the codec so far. You probably don't need to look at this.
            </summary>
        </member>
        <member name="T:Ionic.Zlib.ZlibConstants">
            <summary>
            A bunch of constants used in the Zlib interface.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.WindowBitsMax">
            <summary>
            The maximum number of window bits for the Deflate algorithm.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.WindowBitsDefault">
            <summary>
            The default number of window bits for the Deflate algorithm.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_OK">
            <summary>
            indicates everything is A-OK
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_STREAM_END">
            <summary>
            Indicates that the last operation reached the end of the stream.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_NEED_DICT">
            <summary>
            The operation ended in need of a dictionary. 
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_STREAM_ERROR">
            <summary>
            There was an error with the stream - not enough data, not open and readable, etc.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_DATA_ERROR">
            <summary>
            There was an error with the data - not enough data, bad data, etc.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_BUF_ERROR">
            <summary>
            There was an error with the working buffer.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.WorkingBufferSizeDefault">
            <summary>
            The size of the working buffer used in the ZlibCodec class. Defaults to 8192 bytes.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.WorkingBufferSizeMin">
            <summary>
            The minimum size of the working buffer used in the ZlibCodec class.  Currently it is 128 bytes.
            </summary>
        </member>
        <member name="T:Ionic.Zlib.ZlibStream">
             <summary>
             Represents a Zlib stream for compression or decompression.
             </summary>
             <remarks>
            
             <para>
             The ZlibStream is a <see href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a <see cref="T:System.IO.Stream"/>.  It adds ZLIB compression or decompression to any
             stream.
             </para>
            
             <para> Using this stream, applications can compress or decompress data via
             stream <c>Read()</c> and <c>Write()</c> operations.  Either compresssion or
             decompression can occur through either reading or writing. The compression
             format used is ZLIB, which is documented in <see href="http://www.ietf.org/rfc/rfc1950.txt">IETF RFC 1950</see>, "ZLIB Compressed
             Data Format Specification version 3.3". This implementation of ZLIB always uses
             DEFLATE as the compression method.  (see <see href="http://www.ietf.org/rfc/rfc1951.txt">IETF RFC 1951</see>, "DEFLATE
             Compressed Data Format Specification version 1.3.") </para>
            
             <para>
             The ZLIB format allows for varying compression methods, window sizes, and dictionaries.
             This implementation always uses the DEFLATE compression method, a preset dictionary,
             and 15 window bits by default.
             </para>
            
             <para>
             This class is similar to <see cref="T:Ionic.Zlib.DeflateStream"/>, except that it adds the
             RFC1950 header and trailer bytes to a compressed stream when compressing, or expects
             the RFC1950 header and trailer bytes when decompressing.  It is also similar to the
             <see cref="T:Ionic.Zlib.GZipStream"/>.
             </para>
             </remarks>
             <seealso cref="T:Ionic.Zlib.DeflateStream"/>
             <seealso cref="T:Ionic.Zlib.GZipStream"/>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode)">
             <summary>
             Create a <c>ZlibStream</c> using the specified <c>CompressionMode</c>.
             </summary>
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Compress</c>, the <c>ZlibStream</c>
               will use the default compression level. The "captive" stream will be
               closed when the <c>ZlibStream</c> is closed.
             </para>
            
             </remarks>
            
             <example>
             This example uses a <c>ZlibStream</c> to compress a file, and writes the
             compressed data to another file.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".zlib"))
                 {
                     using (Stream compressor = new ZlibStream(raw, CompressionMode.Compress))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".zlib")
                 Using compressor As Stream = New ZlibStream(raw, CompressionMode.Compress)
                     Dim buffer As Byte() = New Byte(4096) {}
                     Dim n As Integer = -1
                     Do While (n &lt;&gt; 0)
                         If (n &gt; 0) Then
                             compressor.Write(buffer, 0, n)
                         End If
                         n = input.Read(buffer, 0, buffer.Length)
                     Loop
                 End Using
                 End Using
             End Using
             </code>
             </example>
            
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel)">
             <summary>
               Create a <c>ZlibStream</c> using the specified <c>CompressionMode</c> and
               the specified <c>CompressionLevel</c>.
             </summary>
            
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Decompress</c>, the level parameter is ignored.
               The "captive" stream will be closed when the <c>ZlibStream</c> is closed.
             </para>
            
             </remarks>
            
             <example>
               This example uses a <c>ZlibStream</c> to compress data from a file, and writes the
               compressed data to another file.
            
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".zlib"))
                 {
                     using (Stream compressor = new ZlibStream(raw,
                                                               CompressionMode.Compress,
                                                               CompressionLevel.BestCompression))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".zlib")
                     Using compressor As Stream = New ZlibStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
            
             <param name="stream">The stream to be read or written while deflating or inflating.</param>
             <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,System.Boolean)">
             <summary>
               Create a <c>ZlibStream</c> using the specified <c>CompressionMode</c>, and
               explicitly specify whether the captive stream should be left open after
               Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Compress</c>, the <c>ZlibStream</c> will use
               the default compression level.
             </para>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               <see cref="T:System.IO.MemoryStream"/> that will be re-read after
               compression.  Specify true for the <paramref name="leaveOpen"/> parameter to leave the stream
               open.
             </para>
            
             <para>
             See the other overloads of this constructor for example code.
             </para>
            
             </remarks>
            
             <param name="stream">The stream which will be read or written. This is called the
             "captive" stream in other places in this documentation.</param>
             <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
             <param name="leaveOpen">true if the application would like the stream to remain
             open after inflation/deflation.</param>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel,System.Boolean)">
             <summary>
               Create a <c>ZlibStream</c> using the specified <c>CompressionMode</c>
               and the specified <c>CompressionLevel</c>, and explicitly specify
               whether the stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               This constructor allows the application to request that the captive
               stream remain open after the deflation or inflation occurs.  By
               default, after <c>Close()</c> is called on the stream, the captive
               stream is also closed. In some cases this is not desired, for example
               if the stream is a <see cref="T:System.IO.MemoryStream"/> that will be
               re-read after compression.  Specify true for the <paramref name="leaveOpen"/> parameter to leave the stream open.
             </para>
            
             <para>
               When mode is <c>CompressionMode.Decompress</c>, the level parameter is
               ignored.
             </para>
            
             </remarks>
            
             <example>
            
             This example shows how to use a ZlibStream to compress the data from a file,
             and store the result into another file. The filestream remains open to allow
             additional data to be written to it.
            
             <code>
             using (var output = System.IO.File.Create(fileToCompress + ".zlib"))
             {
                 using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
                 {
                     using (Stream compressor = new ZlibStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, true))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
                 // can write additional data to the output stream here
             }
             </code>
             <code lang="VB">
             Using output As FileStream = File.Create(fileToCompress &amp; ".zlib")
                 Using input As Stream = File.OpenRead(fileToCompress)
                     Using compressor As Stream = New ZlibStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, True)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
                 ' can write additional data to the output stream here.
             End Using
             </code>
             </example>
            
             <param name="stream">The stream which will be read or written.</param>
            
             <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
            
             <param name="leaveOpen">
             true if the application would like the stream to remain open after
             inflation/deflation.
             </param>
            
             <param name="level">
             A tuning knob to trade speed for effectiveness. This parameter is
             effective only when mode is <c>CompressionMode.Compress</c>.
             </param>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.Dispose(System.Boolean)">
            <summary>
              Dispose the stream.
            </summary>
            <remarks>
              <para>
                This may or may not result in a <c>Close()</c> call on the captive
                stream.  See the constructors that have a <c>leaveOpen</c> parameter
                for more information.
              </para>
              <para>
                This method may be invoked in two distinct scenarios.  If disposing
                == true, the method has been called directly or indirectly by a
                user's code, for example via the public Dispose() method. In this
                case, both managed and unmanaged resources can be referenced and
                disposed.  If disposing == false, the method has been called by the
                runtime from inside the object finalizer and this method should not
                reference other objects; in that case only unmanaged resources must
                be referenced or disposed.
              </para>
            </remarks>
            <param name="disposing">
              indicates whether the Dispose method was invoked by user code.
            </param>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
             Read data from the stream.
             </summary>
            
             <remarks>
            
             <para>
               If you wish to use the <c>ZlibStream</c> to compress data while reading,
               you can create a <c>ZlibStream</c> with <c>CompressionMode.Compress</c>,
               providing an uncompressed data stream.  Then call <c>Read()</c> on that
               <c>ZlibStream</c>, and the data read will be compressed.  If you wish to
               use the <c>ZlibStream</c> to decompress data while reading, you can create
               a <c>ZlibStream</c> with <c>CompressionMode.Decompress</c>, providing a
               readable compressed data stream.  Then call <c>Read()</c> on that
               <c>ZlibStream</c>, and the data will be decompressed as it is read.
             </para>
            
             <para>
               A <c>ZlibStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but
               not both.
             </para>
            
             </remarks>
            
             <param name="buffer">
             The buffer into which the read data should be placed.</param>
            
             <param name="offset">
             the offset within that data array to put the first byte read.</param>
            
             <param name="count">the number of bytes to read.</param>
            
             <returns>the number of bytes read</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.Seek(System.Int64,System.IO.SeekOrigin)">
             <summary>
             Calling this method always throws a <see cref="T:System.NotSupportedException"/>.
             </summary>
             <param name="offset">
               The offset to seek to....
               IF THIS METHOD ACTUALLY DID ANYTHING.
             </param>
             <param name="origin">
               The reference specifying how to apply the offset....  IF
               THIS METHOD ACTUALLY DID ANYTHING.
             </param>
            
             <returns>nothing. This method always throws.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.SetLength(System.Int64)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotSupportedException"/>.
            </summary>
            <param name="value">
              The new value for the stream length....  IF
              THIS METHOD ACTUALLY DID ANYTHING.
            </param>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
             Write data to the stream.
             </summary>
            
             <remarks>
            
             <para>
               If you wish to use the <c>ZlibStream</c> to compress data while writing,
               you can create a <c>ZlibStream</c> with <c>CompressionMode.Compress</c>,
               and a writable output stream.  Then call <c>Write()</c> on that
               <c>ZlibStream</c>, providing uncompressed data as input.  The data sent to
               the output stream will be the compressed form of the data written.  If you
               wish to use the <c>ZlibStream</c> to decompress data while writing, you
               can create a <c>ZlibStream</c> with <c>CompressionMode.Decompress</c>, and a
               writable output stream.  Then call <c>Write()</c> on that stream,
               providing previously compressed data. The data sent to the output stream
               will be the decompressed form of the data written.
             </para>
            
             <para>
               A <c>ZlibStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but not both.
             </para>
             </remarks>
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.CompressString(System.String)">
             <summary>
               Compress a string into a byte array using ZLIB.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:Ionic.Zlib.ZlibStream.UncompressString(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:Ionic.Zlib.ZlibStream.UncompressString(System.Byte[])"/>
             <seealso cref="M:Ionic.Zlib.ZlibStream.CompressBuffer(System.Byte[])"/>
             <seealso cref="M:Ionic.Zlib.GZipStream.CompressString(System.String)"/>
            
             <param name="s">
               A string to compress.  The string will first be encoded
               using UTF8, then compressed.
             </param>
            
             <returns>The string in compressed form</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.CompressBuffer(System.Byte[])">
             <summary>
               Compress a byte array into a new byte array using ZLIB.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:Ionic.Zlib.ZlibStream.UncompressBuffer(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:Ionic.Zlib.ZlibStream.CompressString(System.String)"/>
             <seealso cref="M:Ionic.Zlib.ZlibStream.UncompressBuffer(System.Byte[])"/>
            
 